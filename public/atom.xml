<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hrafn.me]]></title>
  <link href="http://hrafn.me/atom.xml" rel="self"/>
  <link href="http://hrafn.me/"/>
  <updated>2012-09-02T19:10:03+04:00</updated>
  <id>http://hrafn.me/</id>
  <author>
    <name><![CDATA[Alexander 'Hrafn' Ivanov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Основы Chef. Поиск и Data Bags]]></title>
    <link href="http://hrafn.me/2012/04/chef-basics-search-and-databags"/>
    <updated>2012-04-23T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/04/chef-basics-search-and-databags</id>
    <content type="html"><![CDATA[<p><a href="http://wiki.opscode.com/display/chef/Introduction+to+Search+and+Data+Bags">Ссылка на оригинал</a></p>

<p>Это последняя часть из Chef Basics. И посвящена она краткому описанию (очень краткому) функций поиска и data bags, не знаю как перевести на русский это словосочетание.
В ближайшее время постараюсь собрать все четыре части в PDF.
Также в планах дальнейшие переводы по Chef: Chef.Architecture и Chef Essentials. Но об этом позже :)</p>

<!--more-->


<h2>Поиск</h2>

<p>Поиск - это функциональность Chef, позволяющая использовать полнотекстовый поисковый движок (основанный на Apache Solr) для запроса информации об инфраструктуре и приложениях. Информация, содержащаяся в аттрибутах узла, data bags (смотрите ниже), окружения, роли и API клиентов также могут запрашиваться.</p>

<p>Поиск можно использовать как внутри рецептов, так и с рабочей станции Chef, используя knife. Например, в рецепте, можно получить список всех серверов приложений, чтобы добавить их в конфигурацию, относящуюся к балансировщикам нагрузки. Чтобы сделать это, можно найти все узлы, которые используют роль &#8220;appserver&#8221;:</p>

<pre><code>app_servers = search(:node, 'role:appserver')
</code></pre>

<p>Следует заметить, что результаты этого поиска не будут статичными. Наоборот, каждый раз при запуске chef-client, результаты будут отображать серверы приложений в пределах окружения на данный момент. Это дает возможность масштабировать инфраструктуру и быть увереным, что новые компоненты будут в должной степени интегрированы с существующими компонентами, например, балансировщиками нагрузки.</p>

<p>Как вариант, может потребоваться быстро получить список узлов, использующихся как серверы приложений, с рабочей станции:</p>

<pre><code>knife search node 'role:appserver'
</code></pre>

<p>Для получения более подробной информации следует обратиться к <a href="http://wiki.opscode.com/display/chef/Search">Поиску</a>.</p>

<h2>Data Bag</h2>

<p>Data Bags хранят вложенные данные ключ-значение (как аттрибуты) на серверах chef. По данным Data Bag можно производить поиск, также их можно загружать прямо по имени в рецепте. Data Bags глобальны для конкретной установки сервера Chef - их можно представить в качестве аттрибутов для всей инфраструктуры.</p>

<p>Например, указанному узлу требуется множество учетных записей пользователей. Вместо того, чтобы создавать описание ресурса нового пользователя для каждого из них, можно сохранить информацию о каждом пользователе в data bag и упростить рецепт:</p>

<pre><code>search(:users, '*:*') do |u|
    user u["username"] do
        home u["home"]
        shell u["shell"]
        comment u["comment"]
    end
end
</code></pre>

<p>Теперь, всякий раз при необходимости создать пользователя на узлах, можно сделать это просто отредактировав data bag вместо рецепта. Это не только упрощает рецепты, но и позволяет убедиться, что важные данные об инфраструктуре будут доступны для поиска. Доступность для поиска означает, что можно будет быстро получить ответ на вопросы об инфраструктуре, используя knife.Например, скажем, если требуется узнать оболочку по умолчанию пользователя &#8220;hank&#8221;, можно проделать с knife следующее:</p>

<pre><code>knife search users 'username:hank' -a shell
</code></pre>

<p>Для data bags, которые содержат конфиденциальную информацию, Chef предоставляет Encrypted Data Bags, позволяющие безопасно хранить информацию на Chef Server в зашифрованном виде. Для получения более подробной информации о databags и зашифрованных data bags следует обратиться к <a href="http://wiki.opscode.com/display/chef/Data+Bags">Data Bags</a> и <a href="http://wiki.opscode.com/display/chef/Encrypted+Data+Bags">Encrypted Data Bags</a>.</p>

<h2>Краткий итог</h2>

<ul>
<li>Поиск позволяет делать запросы на получение информации об инфраструктуре из рецептов или через knife.</li>
<li>Data bags позволяет хранить данные в виде, пригодном для поиска. Эти данные в дальнейшем могут быть найдены и использованы в рецептах.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Основы Chef. Введение в "Поваренные книги"]]></title>
    <link href="http://hrafn.me/2012/04/chef-basics-introduction-to-cookbooks"/>
    <updated>2012-04-22T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/04/chef-basics-introduction-to-cookbooks</id>
    <content type="html"><![CDATA[<p><a href="http://wiki.opscode.com/display/chef/Introduction+to+Cookbooks+and+More">Ссылка на оригинал</a></p>

<p>&#8220;Поваренные книги&#8221; - способ, которым пользователи Chef и Hosted Chef запаковывают, распространяют и делают общей информацию о конфигурации. Они объединяют все ресурсы, необходимые для автоматизации инфраструктуры, а также облегчают обмен с другими пользователями Chef.</p>

<p>Они содержат рецепты, файлы аттрибутов, шаблоны и другие штуки для настройки.</p>

<!--more-->


<p>При запуске Chef-Client рецепты, перечисленные с списке запуска узла перенаправляются на узел наравне с другим содержимым &#8220;поваренной книги&#8221;, содержащей рецепт. Эти рецепты затем применяются к узлу, приводя его в надлежащее состояние.</p>

<p><a href="http://hrafn.me/media/images/2012/04/22/chef-basics-cookbook.png"><img src="http://hrafn.me/media/images/2012/04/22/chef-basics-cookbook.png" alt="" /></a></p>

<p>Обычно, единственная поваренная книга сожержит информацию, необходимую для настройки одного сервиса или одной части системы. Например, в ней может быть &#8220;поваренная книга&#8221; &#8220;users&#8221; для настройки пользователей, которые должны иметь доступ к системе и &#8220;поваренная книга&#8221; &#8220;apache&#8221; для настройки веб-сервера Apache.</p>

<p>&#8220;Поваренные&#8221; книги могут быть созданы любым человеком, обладающим начальными навыками программирования, и они могут быть написаны без сохранения каких-либо подробностей о развернутом окружении. Это означает, что их можно безопасно распространять и повторно использовать по всей территории организации и компании. Opscode поощряет публикацию пользователями своих &#8220;поваренных книг&#8221; на Opscode Community Site, где можно выбрать уже из более 300 &#8220;поваренных книг&#8221;. В результате, можно устанавливать и настраивать многие полезные вещи даже без написания новой &#8220;поваренной книги&#8221;.</p>

<p>Если репозиторий Chef использует git, можно быстро найти и использовать &#8220;поваренные книги&#8221;, написанные сообществом, используя инструмент командной строки - Knife. Например, для того, чтобы скачать простую &#8220;поваренную книгу&#8221; &#8220;getting-started&#8221;, можно запустить следующее из репозитория chef:</p>

<pre><code>    knife cookbook site install getting-started
</code></pre>

<p>Для выгрузки ее на Chef Server или Hosted Chef:</p>

<pre><code>    knife cookbook upload getting-started
</code></pre>

<p>И, для добавления рецепта &#8220;default&#8221; в эту поваренную книгу для списка запуска узла:</p>

<pre><code>    knife node run_list add my_node 'getting-started::default'
</code></pre>

<p>Chef также предоставляет инструменты для более легкого создания новой поваренной книги. Например, для создания базовой структуры новой поваренной книги в репозитории Chef, можно использовать knife:</p>

<pre><code>    knife cookbook create new_cookbook_name
</code></pre>

<h2>Рецепты</h2>

<p>Рецепты - это файлы Ruby, в которых используется Domain Specific Language (DSL) для определения того, каким образом конкретные части узла следует настраивать. Как можно будет увидеть в последующих секциях, можно использовать данные, совмещенные с возможностью использовать код ruby в рецептах для динамического изменения конфигурации узла.</p>

<p>&#8220;Поваренные книги&#8221; могут содержать множество рецептов, включая рецепты, добавленные в список запуска по их полному имени, используя форму COOKBOOK_NAME::RECIPE_NAME. В список запуска добавляются только роли и рецепты.</p>

<p>Chef, однако, предоставляет укороченную нотацию для имен рецептов и &#8220;поваренных книг&#8221; в команде списка запуска. (Это полезно для рецептов, которые используются в качестве основной конфигурации для набора узлов).</p>

<p>При добавлении COOKBOOK_NAME в список запуска Chef считает, что нужен рецепт с именем &#8220;default&#8221; из &#8220;поваренной книги&#8221; с тем же именем. Чтобы посмотреть на пример такого поведения, можно изменить команду knife, использованную выше, для добавления рецепта в список запуска узла. Успользуя укороченный вариант, можно просто дать команду, приведенную выше:</p>

<pre><code>    knife node run_list add my_node getting-started
</code></pre>

<p>Этом обновленном примере добавляется рецепт &#8220;default&#8221; из &#8220;поваренной книги&#8221; &#8220;getting-started&#8221; в список запуска &#8220;my_node&#8221;, как и прежде.</p>

<h2>Ресурсы и Провайдеры</h2>

<p>Ресурсы - это строительные блоки, которые будут использоваться для создания должным образом настроенного узла. Они представляют собой крос-платформенную абстракцию того, что настраивается на узле - отдельные куски конфигурации системы, которые помещены в рецепты и применяются к узлам.</p>

<p>Ключевой особенностью ресурсов является то, что они позволяют сфокусироваться на описании конфигурации узла вместо того, чтобы указывать, каким образом конкретная задача должна быть выполнена.</p>

<p>Например, следующий ресурс добавляет пользователя на узел:</p>

<pre><code>    user "sam" do
      home "/home/sam"
      shell "bin/zsh"
      comment "Sam loves DevOps"
      action :create
    end
</code></pre>

<p>Этот ресурс описывает пользователя, &#8220;sam&#8221;, которого необходимо создать на узле. В действительности создание производится Провайдером, который выполняет команды, необходимые для создания нового пользователя.</p>

<p>Отдельные ресурсы могут иметь множество провайдеров, каждый из которых знает, как выполнить необходимые задачи на различных платформах. Chef-client выберет лучшего провайдера для платформы узла. Таким образом, описание этого едиснтвенного ресурса можеь быть использовано для создания пользователя &#8220;sam&#8221; на Linux-системе и FreeBSD-системе, без каких-либо изменений.</p>

<p>Ресурс пользователя, описанный выше, структурирован так же, как все описания ресурсов в Chef Domain Specific Language (DSL):</p>

<pre><code>    resource_type "resource_name" do
      resource_attribute value
      ...
    end
</code></pre>

<p>Тип ресурса относится к виду ресурса, который необходимо настроить. Многие различные ресурсы определяются при помощи Chef DSL. Полный список этих ресурсов можно найти на странице <a href="http://wiki.opscode.com/display/chef/Resources">Ресурсы</a>. Обладая глубокими знаниями Chef, можно даже расширить Chef DSL с помощью собственных ресурсов.</p>

<p>Имя ресурса - это строка, идентифицирующая этот специфичный экзмепляр ресурса. Для конфигурации конкретного узла может потребоваться определение множества ресурсов пользователей, каждый из которых будет иметь свое собственное имя и может быть направлен к другому ресурсу. Имя ресурса, также, по умолчанию, используется как значение для одного из &#8220;аттрибутов ресурса&#8221;. Например, в ресурсе пользователя, описанном выше, имя &#8220;sam&#8221; будет использоваться в качестве имени пользователя для пользователя, которого создаст chef-client.</p>

<p>Аттрибуты ресурса и относящиеся к ним значения описвают желаемое состояние ресурса. Каждый ресурс обладает различными аттрибутами, важными в контексте данного ресурса. Аттрибут &#8220;action&#8221; - это аттрибут, использующийся всеми ресурсами и определяющий, что должно произойти с этим ресурсом. В примере выше, действие &#8220;create&#8221; указывает, что требуется создать пользователя. Когда sam покинет организацию, можно изменить это действие на &#8220;:delete&#8221; для удаления пользователя.</p>

<p>Доступные аттрибуты ресурса и их значения по умолчанию подробно описываются на странице <a href="http://wiki.opscode.com/display/chef/Resources">Ресурсы</a>.</p>

<p>Когда chef-client загружает рецепты с свой список запуска.</p>

<ol>
<li>он запускает каждый рецепт как часть кода ruby</li>
<li>каждый раз, когда ресурс используется, он добавляетя в коллекцию ресурсов для этого узла</li>
<li>затем провайдеры этих ресурсов принимают решение действовать или нет для выполнения описания ресурсов.</li>
</ol>


<p>Таким образом, ключевым принципом Chef является достижение: идемпотентность. Идемпотентность позволяет убедиться, что ресурс может применяться к машине множество раз и всегда будет получен тот же самый результат: должным образом настроенная машина.</p>

<h2>Аттрибуты и Шаблоны</h2>

<p>Аттрибуты обеспечивают хранение вложенных пар ключ-значение данных об узле и его конфигурации. Некоторые аттрибуты автоматически собираются на старте каждого запуска chef-client и включают такую информацию, как IP-адрес узлов, имя хоста или загруженные модули ядра. Другие аттрибуты добавляются из других источников, например, &#8220;поваренные книги&#8221;. (Роли и Окружения также могут устанавливать аттрибуты, об этом будет написано далее).</p>

<p>Аттрибуты позволяют изменить конфигурацию на основе характеристик узла и установить разумные значения по умолчанию для конфигурации сервиса, что также позволяет легко их изменять. Единственный способ установить аттрибуты - файлы аттрибутов в &#8220;поваренной книге&#8221;.</p>

<p>Например, далее устанавливаются некоторые разумные значения по умолчанию для расположения определенного конфигурационного файла:</p>

<pre><code>    default["my_application"]["config_location"] = "/etc/myapp.conf"
</code></pre>

<p>Затем этот аттрибут может использоваться напрямую при контроле ресурсов конфигурационного файла:</p>

<pre><code>    template node["my_application"]["config_location"] do
      action :create
    end
</code></pre>

<p>Определение Шаблона, который является особенностью Chef, позволяет создавать общие файлы, содержание которых может быть сгенерировано автоматически. Если этот файл конфигурации много раз упоминался в рецепте, изменение его расположения - причина изменения одного аттрибута.</p>

<p>Аттрибуты узла также содержат игформацию об узле, которая может использоваться в рецепте:</p>

<pre><code>    if node.attribute?("ec2")
      # Выполнить специфичные для EC2 задачи.
    end
</code></pre>

<p>Это позволит рецепту выполнить некий набор задач по настройке только в том случае, если он был запущен в облаке Amazon EC2. За полной информацией об Аттрибутах необходимо обратиться к <a href="http://wiki.opscode.com/display/chef/Attributes">следующей странице</a>.</p>

<h2>Роли</h2>

<p>Настройка одного узла может потребовать множество различных &#8220;поваренных книг&#8221;. Для упорядочивания в группы похожих возможностей на похожих хостах Chef предоставляет Роли. Роли содержат список запуска (только для узла) и аттрибуты, относящиеся к конкретной функции. Например, можно создать роль &#8220;webserver&#8221;, которяа будет включать список запуска со всеми сервисами, необходимыми для работы типичного веб-сервера в пределах инфраструктуры. Список запуска узла может содержать эти роли.</p>

<p>В случае, если в списке запуска узла находится роль, список запуска самой роли расширяется и добавляется к списку запуска узла, чтобы быть уверенным, что все рецепты для указанной роли применены к узлу.</p>

<p>Роли также могут устанавливать аттрибуты. Установка аттрибутов в ролях позволяет переназначить аттрибуты по умолчанию общей &#8220;поваренной&#8221; книги на значения, более соответствующие узлу с указанной ролью.</p>

<p><a href="http://hrafn.me/media/images/2012-04/22/chef-basics-roles.png"><img src="http://hrafn.me/media/images/2012/04/22/chef-basics-roles.png" alt="" /></a></p>

<h2>Окружения</h2>

<p>Окружения в Chef предоставляют механизм для управления такими разлиными окружениями, как production, staging, development и testing в пределах одного Chef Server или организации Hosted Chef. С помощью окружений можно указать &#8220;список запуска&#8221; в роли, ограничение по версии &#8220;поваренной книги&#8221; и аттрибуты окружения для каждого их них по отдельности. Роли отличаются в это плане тем, что группируют системы по определенным функциям и могут распространяться между окружениями - например: сервер приложений, веб-сервер, сервер баз данных. Таким образом, есть возможность иметь список запуска для каждого окружения внутри роли - например: в окружении development сервер приложений должен подключаться к другому балансировщику нагрузки, находящимся в окружении test, и этим можно управлять внутри одного рецепта.</p>

<p>Можно создавать и управлять окружениями множеством способов, адаптируя их для удовлетворения сосбтвенных нужд и нужд инфраструктуры. Обратитесь к странице <a href="http://wiki.opscode.com/display/chef/Environments">Окружения</a> для получения подробностей.</p>

<h2>Кратко об описанном</h2>

<ul>
<li>Поваренные книги содержат рецепты, файлы аттрибутов и других информацию о конфигурации</li>
<li>Ресурсы представляют собой строительные блоки для рецептов и описывают конкретную часть конфигурации узла</li>
<li>Ресурсы идемпотентны. Применение одного и того же ресурса дважды должно приводить к одному и тому же результату</li>
<li>Провайдеры применяют необходимые действия, требующиеся для приведения узла в состояние согласно описанию ресурса</li>
<li>Аттрибуты предоставляет настраиваемые параметры, которые могут использоваться в рецептах, так же как информация об узле</li>
<li>Роли предоставляют способ описания определенной функции или типа узла. Роли имеют списки запуска и аттрибуты.</li>
<li>Окружения предоставляют способ управления различными инфраструктурными пространствами в пределах одного экземпляра Chef.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Основы Chef. Базовые компоненты]]></title>
    <link href="http://hrafn.me/2012/04/chef-basics-core-components"/>
    <updated>2012-04-21T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/04/chef-basics-core-components</id>
    <content type="html"><![CDATA[<p><a href="http://wiki.opscode.com/display/chef/Core+Components">Ссылка на оригинал</a></p>

<p>Чтобы научиться использовать Chef, необходимо понимать, что из себя представляет каждый его компонент и каким образом они работают вместе. (http://wiki.opscode.com/display/chef/Core+Components)</p>

<!--more-->


<h2>Создание инфраструктуры</h2>

<h3>Узлы</h3>

<p>Узел - это хост, на котором работает клиент Chef. Основная особенность узла, с точки зрения Chef, - его аттрибуты и его список запуска. Узлы - это те вещи, к которым применяются Рецепты и Роли. Для работы с Узлами в любое время потребуется:</p>

<ul>
<li>добавить рецепт в систему</li>
<li>обновить аттрибуты</li>
</ul>


<h4>Список запуска (run_list)</h4>

<p>В простейшем случае, &#8220;список запуска&#8221; - это список рецептов, которые узел запускает. При условии, что метаданные &#8220;поваренной книги&#8221; корректные, можно просто поместить рецепт, который необходимо запустить, в &#8220;список запуска&#8221;, и зависимые рецепты будут запущены автоматически при необходимости. Порядок важен: порядок, в котором рецепты перечислены в &#8220;списке запуска&#8221;, в точности соответствует тому, в котором chef будет их запускать.</p>

<p>При более продвинутом использовании, &#8220;список запуска&#8221; будет включать роли, назначенные узлу в дополнение к любому явно назначенному набору рецептов. В этом случае, когда клиент Chef запускается, &#8220;список запуска&#8221; &#8220;растягивается&#8221; в список рецептов, замещая записи роли в &#8220;списке запуска&#8221; списком рецептов роли, указанным в &#8220;списке запуска&#8221;.</p>

<h3>Аттрибуты узла</h3>

<p>Узлы и роли связаны аттрибутами, которые представляют собой структуру вложенных пар ключ - значение. Аттрибуты узлов и ролей в целом используются в качестве основы для аттрибутов ресурсов. Например, сервер может использовать одну версию nginx, но необходимо установить версию новее на тестовый сервер для проверки. Используя аттрибуты узла или роли для указания версии, можно использовать один и тот же рецепт как для одного, так и для другого окружения.</p>

<p>Chef позволяет устанавливать аттрибуты в файлах аттрибутов (кроме мириада других способов). Код в этих файлах доступен узлу, на котором работает chef, и управляет аттрибутами на этом узле напрямую. В терминах ruby, значение <code>self</code> в файлах аттрибутов - это сам узел. Используя эти фйлы, можно рассчитывать, что узел имеет нормальное значение для аттрибута, когда рецепт пишется без учета того, что узел может не иметь определения этого аттрибута.</p>

<p>Продвинутые пользователи Chef часто активно используют аттрибуты, определенные в ролях, для управления аттрибутами на нескольких узлах сразу.</p>

<h3>Роли</h3>

<p>Роль предоставляет возможность группировать подобные возможности подобных узлов. В масштабе веба, почти никогда не бывает чего-то одного, так что можно использовать роли для представления частей конфигурации, которые будут общими для группы узлов. Роли состоят из тем же частей, что и узлы: аттрибуты и &#8220;списки запуска&#8221;. Когда клиент Chef запускается, он объединяет свои собственные аттриуты и &#8220;список запуска&#8221; с теми из ролей, которые ему были назначены.</p>

<h2>Настройка Узлов</h2>

<h3>Поваренные книги (Cookbooks)</h3>

<p>&#8220;Поваренная книга&#8221; - это набор рецептов, определений ресурсов, аттрибутов, библиотеки, файла &#8220;поваренной книги&#8221; и файлов шаблонов, которые chef использует для настройки системы, плюс метаданные. &#8220;Поваренные книги&#8221; обычно концентрируются вокруг настройки одного пакета или сервиса. &#8220;Поваренная книга&#8221; MySQL, например, содержит рецепты как для клиента, так и для сервера, плюс файл аттрибутов для настройки по умолчанию для значений, которые могут меняться.</p>

<p>&#8220;Поваренные книги&#8221; - единица распространения и общего доступа в Chef. Большую часть времени использования Chef составляет написание &#8220;поваренных книг&#8221;.</p>

<h3>Рецепты</h3>

<p>Рецепты - это файлы, куда записываются Ресурсы (рассмотренные ниже). Рецепты могут также содержать произвольный код на Ruby, однако необходимо понимать немного, как Chef использует это. Каждый запуск Chef - процесс из двух стадий: на первой, вызывается компиляция, Chef проверяет файлы рецептов, создавая список ресурсов. На следующей стадии, Chef выполняет желаемое действие для каждого ресурса на провайдере этого ресурса. Любой произвольный код в рецепте будет запущен на этапе компиляции, а не на этапе выполнения. Для того, чтобы отложит выполнение до этапа выполнения, используется ресурс ruby_block.</p>

<h3>Метаданные</h3>

<p>&#8220;Поваренные&#8221; книги часто ссылаются на &#8220;поваренных книгах&#8221; как необходимое условие. Чтобы сервер знал, какие &#8220;поваренные книги&#8221; необходимо отправить клиенту, &#8220;поваренной книге&#8221;, зависящей от других, необходимо показать, что эта зависимость где-то находится. Это &#8220;где-то находится&#8221; и есть в метаданных &#8220;поваренной книги&#8221;. Зависимость отслеживается в большей видимой части метаданных, но метаданные могут также содержать информацию об авторстве, лицензии, описание &#8220;поваренной книги&#8221;, какая платформа требуется для работы на ней, и будет или нет &#8220;поваренная книга&#8221; нормально работать с другими. На данный момент Chef поддерживает намного больше полей для метаданных, чем реально используется, но поддержка произвольной информации о зависимостях абсолютно необходима, поскольку иначе узлы могут не получить все требуемые &#8220;поваренные книги&#8221; по причине неполной информации.</p>

<h3>Ресурсы</h3>

<p>Ресурс - как правило, кросс-платформенная абстракция того, что настраивается на хосте. Например, пакеты могут быть установлены через apt, yum или порты и пакетную систему BSD, но ресурс пакетов абстрагируется от этих разных способов, что позволяет просто указать, что пакет должен быть установлен кросс-платформенным способом. Ресурсы Chef по большей части просто контейнеры для данных, с некоторой функциональностью базовой проверки.</p>

<p>Ресурсы декларируются в Рецептах и Определениях. Они являются базовой частью работы в Chef.</p>

<h4>Аттрибуты Ресурсов</h4>

<p>Как уже упоминалось, ресурсы, по большей части, являются контейнерами для данных. Аттрибуты же - это части данных, которые эти ресурсы содержат. В случае управления пакетами, это может быть имя пакеты, который необходимо установить, версия его для установки или опции, передаваемые менеджеру пакетов.</p>

<p><em>Аттрибуты или Параметры Ресурса.</em>
Разработчики Chef обсуждали переименовывать ли Аттрибуты Ресурса в &#8220;параметры&#8221; для переопределения термина &#8220;аттрибут&#8221;, так как этот термин также используется для описания данных, относящихся к узлам и ролям. Текущий документ использует термин &#8220;аттрибут&#8221;, и необходимо помнить, что его значения отличается от значения аттрибутов узлов.</p>

<h4>Действия</h4>

<p>Действие - это то, что от Chef требуется сделать с ресурсом: должен ли быть пакет установлен? Обновлен ли до новой версии? Удален? Действия, в основном, специфичны для ресурса, но все ресурсы поддерживают действие &#8220;ничего&#8221;, смысл которого заключен в его имени.</p>

<h3>Провайдер</h3>

<p>Провайдер - это специфичная для платформы реализация того, что ресурс абстрагирует. На Red Hat или CentOS ресурс пакетов будет использовать провайдер пакетов yum для установки пакетов, а на Debian или Ubuntu будет использоваться провайдер apt. Провайдеры очень разумны: они несут ответственность за идемпотентность Chef&#8217;а, проверяя, необходимо ли применить действие, и отправляя команду системе для применение действия. В случае провайдеров пакетов, они сначала проверяют, установлена ли нужная версия пакета, и запускают, при необходимости, yum, apt или другие менеджеры пакетов для установки или обновления. При работе с Chef обычно не нужно беспокоиться о провайдерах. В случае, когда это делается, Chef предоставляет ресурсы &#8220;для ускорения&#8221;, которые всегда используют нужные провайдеры. Например, ресурсы dpkg_package и rpm_package позволяют установить пакет напрямую с файловой системы, используя провайдеры, специфичные для этих менеджеров пакетов.</p>

<p>Провайдеры применяют действия на Ресурсах. Конкретный Узел выбирает, что Провайдер должен использовать для Ресурса по умолчанию, или Ресурс может указать конкретного провайдера.</p>

<h3>Поиск</h3>

<p>Поиск создан Chef&#8217;ом и позволяет запрашивать произвольные данные об инфраструктуре. Наиболее часто, этот сервис используется при поиске вызова в рецепте.</p>

<h3>Data Bags</h3>

<p>Data Bags хранит вложенные данные ключ-значение (как аттрибуты) на сервере chef. По данным Data Bag можно искать, также они могут быть загружены напрямую по имени в рецепте. Data bags глобальны для установки chef-server - их можно представить как аттрибуты всей инфраструктуры.</p>

<h3>Окружения</h3>

<p>Окружения предоставляют механизм управления такими различными архитектурными сегментированными пространствами, как &#8220;production&#8221;, &#8220;staging&#8221;, &#8220;development&#8221;, &#8220;testing&#8221; и т.д. с единственным экземпляром Chef (или одной организацией, в случае, Hosted Chef). С помощью окружений можно указать список запуска в роли для конкретного окружения, версию &#8220;поваренной книги&#8221; и аттрибуты: это позволяет установить политики для указания того, какая версия конкретной поваренной книги можеь быть использована в сегменте инфраструктуры. Окружения не являются множеством ограничений конкретных взаимодействий на единой системе, они действуют в качестве ограничения версии &#8220;поваренной книги&#8221; над сгруппированными системами, на которые  распространяется использование - например: development, test, production - где существуют серверы приложений и серверы баз данных. Роли - это сгруппированные системы, которые действуют как функции и которые могут распространяться на окружения - например: сервер приложений, веб-сервер, сервер баз данных. Таким образом, можно иметь &#8220;списки запуска&#8221; для каждого окружения внутри ролей - например: в окружении development требуется, чтобы сервер приложений подключался к другому балансировщику нагрузки, который работает в тестовом окружении - которые включены в тот же самый рецепт.</p>

<h2>Управление Chef</h2>

<h3>Knife</h3>

<p>Knife - интерфес командной строки для сервера Chef, с помощью которого также предоставляются некоторые возможности, полезные для chef-solo как вариант.</p>

<h3>Консоль Управления</h3>

<p>Консоль Управления - это графический веб-интерфейс для API chef-server. Многие компоненты могут управляться через эту консоль, включая пользователей, узлы, роли, поваренные книги, data bags и API клиентов. Поиск также может производиться через консоль. Консоль Управления Hosted Chef также позволяет клиентам редактирвоать информацию в собственном профилде пользователя, например, информацию об учетной записи или биллинг, а также управлять Авторизацией Hosted Chef.</p>

<h3>Shef</h3>

<p>Shef - это интерактивная консоль chef - она позволяет создавать, запускать и проверять рецепты интерактивно.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Основы Chef. Введение в архитектуру]]></title>
    <link href="http://hrafn.me/2012/04/chef-basics-architecture"/>
    <updated>2012-04-20T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/04/chef-basics-architecture</id>
    <content type="html"><![CDATA[<p><a href="http://wiki.opscode.com/display/chef/Architecture+Introduction">Ссылка на оригинал</a></p>

<p>Эта статья является введением в архитектуру Chef.
Здесь описываются основные функции сервера Chef (Chef Server), функции узлов (Node) и управляющих станций Chef (Chef Workstation) при использовании Chef, а также взаимодействие между этими компонентами.</p>

<p>Позволю себе сделать несколько замечаний.
Однозначных русских вариантов основных понятий я скорее не нашел. Каждый пишущий про Chef, переводит по-своему. Если какие-то варианты переводов покажутся неверными или читающий может предложить свой, более адекватный, милости прошу: пишите в Twitter, G+, Jabber или на почту.
Кроме того, перевод не профессиональный. Я перевожу, кроме того, далеко не все, поскольку считаю, что главное передать смысл.</p>

<!--more-->


<p><a href="http://hrafn.me/media/images/2012/04/20/chef-basics-nwc.png"><img src="http://hrafn.me/media/images/2012/04/20/chef-basics-nwc.png" alt="" /></a></p>

<h2>Chef Server, Узлы и Управляющие станции</h2>

<p>При использовании Chef для управления инфраструктурой придется иметь дело с тремя типами хостов: сервером Chef, узлами и управляющими станциями Chef.</p>

<h3>Chef Server</h3>

<p>Chef Server - это центральное хранилище конфигурационных данных инфраструктуры. Chef Server хранит данные, необходимые для настройки узлов, а также предоставляет поиск, позволяющий динамически управлять конфигурацией узлов на основе данных. REST API делает эти данные доступными для узлов и управляющих станций. Дополнительно, есть возможность использовать Chef Server&#8217;s WebUI для управления инфраструктурой через веб-интерфейс.</p>

<h3>Узлы</h3>

<p>Узел - любой хост, настроенный на использование клиента chef. Клиент chef работает на узле, обращаясь к Chef Server за информацией, необходимой для настройки узла. С точки зрения сервера Chef, узел - чуть больше, чем список запуска (run_list), список рецептов и ролей, которые будут применены к узлу и будут определять его конфигурацию, и аттрибуты, набор данных о самом узле. Поскольку Узел - это машина, на которой работает chef-client, узлы иногда рассматриваются как &#8220;клиенты&#8221;. (Это не относится к клиентскому API, которое аутентифицируется через Chef Server API).</p>

<p>В случае, если узлы рассматриваются в качестве &#8220;клиентов&#8221;, предполагается связь между исполняемым файлом chef-client, вызовом API предназначенным для аутентификации и авторизации, используя идентификационную информацию в объекте клиентского API, для сохранения объекта узла на сервере.</p>

<h3>Управляющая станция Chef</h3>

<p>Управляющая станция - это хост, использующийся для изменения &#8220;поваренных книг&#8221; и других конфигурационных данных - обычно, это рабочая станция системного администратора. Также управляющая станция имеет два ключевых компонента:</p>

<ol>
<li>knife - приложение. поставляемое вместе с chef</li>
<li>репозиторий, содержащий документы конфигурации инфраструктуры</li>
</ol>


<p>Как будет видно в дальнейшем, эти документы конфигурации включают &#8220;поваренные книги&#8221;, роли, data bags и многое другое. В идеале, эти документы находятся под управлением какой-либо системы контроля версий. При использовании knife, рабочая станция используется как для выгрузки конфигурационных данных на Chef Server, так и для взаимодействия с отдельными узлами через SSH-соединение, если это необходимо.</p>

<h2>Клиенты, Аутентификация и Авторизация</h2>

<p>Роль Chef Server внутри инфраструктуры проста. Он хранит информацию о конфигурации, которая загружается на него, и возвращает эту информацию, когда ее запрашивает клиент API.</p>

<p>Chef использует клиентский API и систему аутентификации и авторизации, чтобы быть уверенным, что данные конфигурации могут быть прочитаны и обновлены только теми, кто авторизован. Клиент Chef (работающий на узле) и knife (работающий на управляющей станции) взаимодействуют с Chef Server, используя клиентский API.</p>

<p>Другими словами, клиент Chef - это сам испольняемый файл &#8216;chef-client&#8217;. Клиентский API - объект, который представляется зашифрованной &#8220;личностью&#8221;, использующейся для аутентификации и авторизации в каждом вызове API.</p>

<p>Для того, чтобы быть уверенным, что запросы приходят от известного API, Chef использует шифрование публичным ключом, пользователи Hosted Chef имеют некоторые дополнительные возможности более тонкой настройки. Клиенты API обладают соответствующими приватными и публичными ключами шифрования. Каждый запрос API, сделанный исполняемым файлом chef, подписывается конкретным приватным ключом клиента API. Затем Chef Server проверяет, что запрос соответствует публичныому ключу клиента.</p>

<p>После этого, Chef Server должен убедиться, что клдиент, сделавший запрос, имеет права, достаточные действий, которые запрашиваются (например, выгрузка &#8220;поваренной книги&#8221; или получение run_list.) Этот процесс известен как авторизация. Open Source Chef Server и Hosted Chef используют различные системы авторизации.</p>

<h3>Open Source Chef</h3>

<p>В Open Source Chef определенные клиенты API могут быть помечены как &#8220;admin clients&#8221;. Авторизация для различных действий устанавливается помечен ли клиент API как &#8220;admin&#8221; или нет. Admin clients используются при создании запросов через knife и обладают всеми возможными правами. Не-&#8220;admin&#8221; клиенты обладают ограниченными правами и используются для узлов внутри инфтраструктуры.</p>

<h3>Hosted Chef</h3>

<p>Hosted Chef использует более комплексную систему авторизации, обеспечивающую более точный контроль на основе client-by-client (или user-by-user). В этой системе клиенты API и пользователи могут иметь права на СОЗДАНИЕ, ЧТЕНИЕ, ОБНОВЛЕНИЕ, УДАЛЕНИЕ или права на ВЫДАЧУ ПРАВ для объектов, хранящихся на Hosted Chef (данные узла, данные &#8220;поваренной книги&#8221; и т.д.). Hosted Chef должен убедиться, что делающий запрос клиент имеет соответствующие права на запрашиваемое действие. Для упрощения управления правами Hosted Chef предоставляет множество заранее созданных групп, обладающих правами в соответствие с определенными ролями. Пользователи и клиенты, входящие в группу &#8220;admin&#8221;, имеют все права на все объекты. Не относящиеся к людям клиенты API (такие, как использующиеся узлами) будут автоматически помещены в группу клиентов, которые имеют права, подобные не-административным клиентам в Open Source Chef, тогда как клиенты-люди могут быть помещены в группу &#8220;users&#8221;, которая обладает правами, подобными административным клиентам в Open Source Chef.</p>

<p>Когда chef-client запускается на нвоом узле, Chef спроектирован для автоматического создания нового клиента API для данного узла. По этой причине, поскольку пользователи или административные клиенты настраиваются один раз должным образом для использования knife и подключения через WebUI или Management Console, часто бывает необходимо продумать детали клиентов API, аутентификации и авторизации.</p>

<h2>Hosted Chef</h2>

<p>В дополнение к более точной системы авторизации у Hosted Chef есть еще две концепции, не использующихся в Open Source Chef: Пользователи и Организации.</p>

<h3>Пользователи</h3>

<p>Пользователи - это, что и можно представить, исходя из названия: сертифицированные сущности, используюшиеся людьми для подключения к Hosted Chef. Как и клиенты, у них есть ключи, которые используются для программного подключения к Hosted Chef, через api.opscode.com или knife. Но у них также есть пароли, которые можно использовать для входа на различные веб-страницы, которые отображает Hosted Chef.</p>

<p>Пользователи могут относиться к организации, которая предоставит им соответствующие права для взаимодействия и управления этой организацией. Однако, в отличие от клиентских API, Пользователи могут относиться к более, чем одной организации, например, консультант мог бы создать отдельную организацию для каждого из своих клиентов. При планировании аутентификации и авторизации проще всего рассматривать пользователя как еще одного клиента API.</p>

<p>Пользователи обладают единственной учетной записью для всех страниц Opscode. Одни и те имя и пароль могут использоваться для входа в Hosted Chef Management Console, the Opscode Cookbooks Site или help.opscode.com.</p>

<h3>Организации</h3>

<p>При регистрации в Hosted Chef создается учетная запись пользователя и организация. Организация может представлять собой всю компанию целиком, какой-то отдельный департамент или любой сгруппированный набор серверной инфраструктуры, которым планируется управлять. Организации - это сущности, которые будут оплачиваться при использовании Hosted Chef. За исключением пользователей, ничего общего между организациями не существует. Клиентский API в одной организации не может прочитать данные узла из другой организации.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Немного про дизайн]]></title>
    <link href="http://hrafn.me/2012/04/about-blog-design"/>
    <updated>2012-04-14T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/04/about-blog-design</id>
    <content type="html"><![CDATA[<p>Прошлое сообщение устарело практически через несколько дней после публикации.
Нынешний внешний вид - это уже наверно третий или четвертый вариант, который я пробовал. Если сначала я пытался просто поправить какие-то уже существующие шаблоны действующих блогов под себя, то потом понял, что надо или смирится с наличием недостатков и ограничений, или сделать так, как устроит именно меня и в том виде, который меня устроит. Что я, в конечном итоге, и сделал.</p>

<p>Есть некоторые недоработки, но потихоньку я постараюсь их исправить. Правда, мне кажется, что я это уже писал ранее, но все равно постараюсь. :)</p>

<p>В процессе создания нового CSS перетащил на Jekyll своего друга, чей блог можно посмотреть и почитать на <a href="http://nobodyknows.ru">nobodyknows.ru</a>. К сожалению, он пишет редко, но, быть может, какой-никакой приход читателей сподвигнет его на написание статей о различных экспериментах на компьютерную тематику :)</p>

<p>Как всегда, у меня множество планов на написание и переводы. Очень постараюсь их осуществить.
Кроме того, буду экспериментировать с <a href="http://www.sinatrarb.com/">Sinatra</a>. <a href="http://slavafinn.ru">Мой брат</a> хочет перейти с Wordpress на что-то более легкое, вот и постараюсь ему помочь.</p>

<p>Пока как-то так :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Новый дизайн и смена структуры]]></title>
    <link href="http://hrafn.me/2012/02/19/new-design"/>
    <updated>2012-02-19T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/02/19/new-design</id>
    <content type="html"><![CDATA[<p>Как уже видно пришедшим сюда, я сменил дизайн. Фактически, это получается уже третий вариант. Надеюсь, что окончательный на ближайшее время. Заодно, несколько сменил структуру расположения файлов и сообщений.
Убрал отдельный раздел <strong>Articles</strong>. Ссылки оттуда перенес частично в <a href="http://hrafn.me/links.html"><strong>links</strong></a>, частично просто убрал, поскольку переводы, на которые были указания, сейчас просто лежат в общем списке всех постов.</p>

<!--more-->


<p>Коротко о дизайне.
За основу взят следующий блог - <a href="http://lhzhang.com/">http://lhzhang.com/</a>. Исходники на Github: <a href="https://github.com/waynezhang/blog">https://github.com/waynezhang/blog</a>. Внешний вид переделал самостоятельно, выбирая те цвета и оттенки, которые мне нравятся :)</p>

<p>Тэги в нынешнем виде удалось сделать благодаря Matt Foster <a href="http://hackerific.net/about.html">http://hackerific.net/about.html</a> и его Rakefile: <a href="https://github.com/mattfoster/mattfoster.github.com/blob/master/Rakefile">https://github.com/mattfoster/mattfoster.github.com/blob/master/Rakefile</a>.</p>

<p>Стоит добавить, что наконец я перевел RSS на FeedBurner, и адрес потока окончательно изменился. Кроме того, теперь в панели навигации ссылка работает и указывает туда, куда нужно.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Отображение шрифтов в openSUSE 12.1]]></title>
    <link href="http://hrafn.me/2012/01/opensuse-12-1-fonts"/>
    <updated>2012-01-02T00:00:00+04:00</updated>
    <id>http://hrafn.me/2012/01/opensuse-12-1-fonts</id>
    <content type="html"><![CDATA[<p>Немного скажу касательно отображения шрифтов в последней, на данный момент, версии openSUSE - 12.1.
Собственно, дело в том, что говорить-то особо и не о чем. Поэтому и ранее не писал ничего на эту тему, хотя у меня на ноутбуке установлена именно эта версия дистрибутива практически с того момента, как она вышла в свет. Почему я использую сейчас именно этот дистрибутив - это отдельная история. Быть может позже я про это тоже напишу, но сейчас тема немного другая.</p>

<!--more-->


<p>В предыдущих версиях openSUSE настроить адекватное, на мой взгляд, отображение шрифтов можно было, но несколько сложно. Требовалось много лишних телодвижений, а в итоге результат далеко не всегда получался именно таким, какой хотелось бы видеть. Впрочем, стоит отметить, что с каждым релизом ситуация все больше улучшалась. К сожалению, в основном это было связано не с тем, что разработчики озаботились этим вопросом каким-либо образом, а с тем, что в других дистрибутивах ситуация начала слегка меняться. Сначала разработчики Ubuntu показали очень хороший результат. Потом миру стали известны патчи от Infinality, которые сначала начали применяться в Fedora, а позже появились и в OBS от проекта openSUSE.
Я видел и пробовал и то, и другое. Шрифты с патчами от Infinality в целом смотрелись чуть лучше, но их результат в итоге получался более точечным. Т.е. в некоторых приложениях шрифты смотрелись просто отлично, где-то похуже, а где-то результат применения патчей был не видел совсем.
В отличие от Infinality патчи применяющиеся в Ubuntu давали более комплексный результат. Возможно, это зависит от каких-то дополнительно установленных пакетов, но столько глубоко я не закапывался, кроме того, пакеты в различных дистрах разбиваются на более мелкие совсем по-разному.
Теперь что касается шрифтов в openSUSE 12.1. Упоминающийся далее репозиторий я как-то пробовал использовать в более ранних версиях openSUSE, но результат был несколько далек от ожидаемого. Сейчас все совершенно изменилось. Про что я сейчас и напишу :)</p>

<p>Для получения нужного результата достаточно подключить следующий репозиторий: <a href="http://opensuse-community.org/subpixel/openSUSE_12.1/">Subpixel.repo</a>
Например, скачиваем файл (http://opensuse-community.org/subpixel/openSUSE_12.1/Subpixel.repo) в /etc/zypp/repos.d/ и ставим пакеты из подключенного репозитория. Как минимум, потребуется:</p>

<ul>
<li>fontconfig-2.8.0-88.1.x86_64.rpm</li>
<li>fontconfig-feature-subpixel-hinting-2.8.0-88.1.x86_64.rpm</li>
<li>freetype2-feature-subpixel-hinting-2.4.7-666.1.x86_64.rpm</li>
<li>libpixman-1-0-0.22.2-666.1.x86_64.rpm</li>
</ul>


<p>Остальные необходимые подтянутся по зависимостям. В процессе установки будет задан вопрос о смене поставщика. На него требуется ответить согласием.
После установки будет необходимо или перегрузиться, или, как минимум, перезапустить Х-сервер для применения новых настроек шрифтов.</p>

<p>Как я уже писал однажды, мне предпочтительны следующие шрифты: Droid, Roboto, Liberation. А, например, при написании этой заметки в Gedit использовался PT Mono. В общем, пробуйте, вкусы-то разные у всех. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Смена движка блога прошла успешно]]></title>
    <link href="http://hrafn.me/2011/12/change-blog-engine"/>
    <updated>2011-12-30T00:00:00+04:00</updated>
    <id>http://hrafn.me/2011/12/change-blog-engine</id>
    <content type="html"><![CDATA[<p>Практически под самый Новый Год я все же перевел блог с Wordpress на Jekyll. Не могу сказать, что сразу все получилось. Первая попытка оказалась не совсем удачной. В основном, это связано с тем, что я не до конца разобрался с принципом работы Jekyll и не мог до конца предполагать, что результат получится не совсем тем, что я ожидал.</p>

<p>Пришлось разбираться с проблемами. А заодно переделал и дизайн. Мне кажется, что получилось лучше.</p>

<p>В итоге, вторая попытка оказалась более удачная. Результат Вы сами видите. Кому-то понравится, кому-то нет, кому-то будет все равно.
Ссылки на мои записи, а также на RSS-ленту остались прежними, поэтому, если исключить данное сообщение, многие могут просто не заметить перехода. Если это так, то оно и к лучше. Значит, я сделал максимум того, что мог :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[openSUSE 12.1]]></title>
    <link href="http://hrafn.me/2011/11/opensuse-12-1"/>
    <updated>2011-11-29T23:37:54+04:00</updated>
    <id>http://hrafn.me/2011/11/opensuse-12-1</id>
    <content type="html"><![CDATA[<p>Очень уж давно не писал ничего. Как-то то времени не найти, то желания. Кроме
того, особо ничего интересного не происходило, а плодить бессмысленные посты с
очередным двухсоттысячным описанием настройки чего-либо не хочется.</p>

<p>Из последних новостей имеется только одна - установка основной системой
свежевышедшей openSUSE 12.1. И даже тут рассказывать нечего :) Все работает,
как и должно. Gnome, в третьей своей версии, нравится мне все больше, по-
крайней мере, сильно удобней, чем Unity на Ubuntu, которой я пользуюсь на
работе.</p>

<p>Хотел написать еще некоторые вещи, но что-то SpringPad работать не хочет,
поэтому позже. Есть пара мыслей для небольших заметок.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RHCSA по RHEL6]]></title>
    <link href="http://hrafn.me/2011/07/rhcsa-po-rhel6"/>
    <updated>2011-07-16T16:46:35+04:00</updated>
    <id>http://hrafn.me/2011/07/rhcsa-po-rhel6</id>
    <content type="html"><![CDATA[<p>Вчера сдавал, а точнее, пересдавал экзамен RHCSA. Теперь уже по шестой версии
RHEL. Пересдавать пришлось по той причине, что начиная с RHEL6, изменился весь
стэк сертификации , в связи с этим изменились и курсы, и экзамены
и несколько поменялись темы, присутствующие и там, и там. Вчера же вечером
пришло письмо с сообщением, что экзамен успешно сдан :)</p>

<!--more-->


<p>Почитать про существующие правила и темы, а также про разницу между
предыдущими и нынешними экзаменами можно по следующим ссылкам:</p>

<p><a href="https://www.redhat.com/cour%0Ases/ex200_rhcsa_exam/">https://www.redhat.com/courses/ex200_rhcsa_exam/</a></p>

<p><a href="https://www.redhat.com/tr%0Aaining/policy/recert.html">https://www.redhat.com/training/policy/recert.html</a></p>

<p>Ну и под конец добавлю, уже почти по традиции, и сам сертификат</p>

<p><a href="http://hrafn.me/media/images/2011/07/16/rhcsa_rhel6.png"><img src="http://hrafn.me/media/images/2011/07/16/rhcsa_rhel6.png" alt="" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[RH Knowledgebase] Упрощенная настройка bridge для KVM]]></title>
    <link href="http://hrafn.me/2011/06/bridge-kvm-again"/>
    <updated>2011-06-10T23:20:00+04:00</updated>
    <id>http://hrafn.me/2011/06/bridge-kvm-again</id>
    <content type="html"><![CDATA[<p>Снова перевод очередной заметки из базы знаний Red Hat -
<a href="https://access.redhat.com/kb/docs/DOC-57734">DOC-57734</a>.</p>

<!--more-->


<p><strong>Проблема</strong>: Как настроит бридж для KVM на Red Hat Enterprise Linux 5.5 без редактирования множества файлов вручную?<br/>
<strong>Решение:</strong></p>

<p>Хост должен быть доступен физически либо через последовательный порт,
поскольку изменения в конфигурации сети могут привести к тому, что доступ по
сети будет потерян. Необходимо произвести следующее:</p>

<pre><code>    # virsh net-list
    # virsh net-create bridge_custom (bridge name)

    default1
    f7e96e6f-7946-46f4-96c4-29f288d88c21

    ## Change 'forward mode' to 'route'
</code></pre>

<p>После этого новый файл конфигурации необходимо поместить в
/etc/libvirt/quemu/networks/ с названием файла тем же, что и название бриджа.</p>

<pre><code>    # /etc/libvirt/qemu/networks/bridge_custom.xml
</code></pre>

<p>Затем определить новый бридж, используя команду, указанную далее:</p>

<pre><code>    # virsh define /etc/libvirt/qemu/networks/bridge_custom.xml
</code></pre>

<p>Для получения более подробной информации о конфигурации бриджа можно также
посмотреть в этой статье:</p>

<p><a href="https://access.redhat.com/kb/doc%0As/DOC-19071">https://access.redhat.com/kb/docs/DOC-19071</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[RH Knowledgebase] Как восстановить базу данных RPM]]></title>
    <link href="http://hrafn.me/2011/05/rh-knowledgebase-kak-vosstanovit-bazu-dannyx-rpm"/>
    <updated>2011-05-05T15:00:11+04:00</updated>
    <id>http://hrafn.me/2011/05/rh-knowledgebase-kak-vosstanovit-bazu-dannyx-rpm</id>
    <content type="html"><![CDATA[<p>Перевод заметки из базы знаний Red Hat: DOC-6904 (<a href="https://access.redhat.com/kb/docs/DOC-6904">https://access.redhat.com/kb/docs/DOC-6904</a>)</p>

<!--more-->


<p>Иногда база данных RPM &#8220;залипает&#8221;. Одной из причин этой проблемы - убийство процесса, работающего с базой данных, что приводит к неверной информации о состоянии блокировки и ограничению доступа последующих процессов к базе
данных. Так что, необходимо убедиться, что процесс действительно завис до
того, как убить его - если процесс использует большое количество процессорного
времени, то возможно, что он продолжает выполнять полезную работу. Информация
о состоянии блокировки должна быть восстановлена вручную, чтобы устранить
&#8220;зависание&#8221; и позволить rpm нормально функционировать.</p>

<p>&#8220;Убийство&#8221; процесса (иногда это происходит при пропадании электропитания,
иногда происходит в случае падения стороннего программного обеспечения без
очистки информации о состоянии блокировки при выходе, иногда из-за
нетерпеливого администратора) может привести к небольшим повреждениям базы
данных RPM &#8216;SleepyCat db&#8217;. В таком случае, необходимо удалить файлы, хранящие
информацию о состоянии блокировки (эти файлы начинают с двух нижних
подчеркиваний, например, &#8220;__db&#8221;). Так как эти файлы автоматически создаются
заново при отсутствии, это достаточно безопасная операция.</p>

<p><strong>Предупреждение: очень</strong> важно убедиться, что никакой запущенных процесс не обращается к базе данных RPM, перед тем, как удалять &#8216;/var/lib/rpm/<strong>db*&#8217;. Если такая проверка затруднена, удаление </strong>db* должно производиться в single user mode. В действительности, init-скрипты RHEL делают это автоматически, так перезагрузки обычно достаточно.</p>

<p>Далее с осторожностью проделайте следующее:</p>

<ol>
<li><p>Перед попыткой восстановления базы, СНАЧАЛА сделайте резерную копию.</p>

<p> # cd /var/lib
 # tar zcvf /var/preserve/rpmdb-[today&#8217;s date].tar.gz rpm</p></li>
<li><p>Проверьте целостность с помощью</p>

<pre><code> # cd /var/lib/rpm
 # rm -f __db*
 # /usr/lib/rpm/rpmdb_verify Packages
</code></pre></li>
<li><p>Далее проделайте следующее:</p>

<p> # mv Packages Packages.orig</p>

<pre><code> # /usr/lib/rpm/rpmdb_dump Packages.orig | /usr/lib/rpm/rpmdb_load Packages
 # /usr/lib/rpm/rpmdb_verify Packages
 # rpm -qa
</code></pre></li>
<li><p>И в итоге восстановите базу данных</p>

<p> # rpm -vv &#8211;rebuilddb</p></li>
</ol>


<p><strong>Дополнительная информация:</strong> Подробные заметки о восстановлении базы данных RPM можно найти здесь: <a href="http://people.redhat.com/berrange/notes/rpmrecovery.html">http://people.redhat.com/berrange/notes/rpmrecovery.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[RH Knowledgebase] USB 3.0 support in Red Hat]]></title>
    <link href="http://hrafn.me/2011/05/usb-3-0-support-in-red-hat"/>
    <updated>2011-05-04T14:57:54+04:00</updated>
    <id>http://hrafn.me/2011/05/usb-3-0-support-in-red-hat</id>
    <content type="html"><![CDATA[<p>Давненько я уже не переводил заметки из Red Hat Knowledgebase, так что вот еще одна :) <a href="https://access.redhat.com/kb/docs/DOC-55131">Оригинал</a></p>

<h3>Вопрос:</h3>

<p>Есть ли в Red Hat Enterprise Linux 5 поддержка USB 3.0?</p>

<h3>Ответ:</h3>

<p>USB 3.0 не поддерживается в RHEL5</p>

<p>Поддержка доступна в RHEL6 при помощи модуля ядра &#8217;<strong>xhci_hcd</strong>&#8217;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fedora and Infinality patches]]></title>
    <link href="http://hrafn.me/2011/04/fedora-and-infinality-patches"/>
    <updated>2011-04-19T13:17:27+04:00</updated>
    <id>http://hrafn.me/2011/04/fedora-and-infinality-patches</id>
    <content type="html"><![CDATA[<p>На мой взгляд, патчи для Cairo и Freetype от <a href="http://www.infinality.net/blog/">Infinality</a> довольно существенно улучшают
отображение шрифтов в Fedora. Я долгое время ими пользовался. Кроме того, в
случае, когда ставил Fedora другим людям, пакеты с патчами также ставил. Но в
последнее время сталкиваюсь с проблемами при их использовании. Начнем по
порядку.</p>

<!--more-->


<p>Обычно, после установки системы, я подключаю <a href="http://www.infinality.net/fedora/linux/">репозиторий Infinality</a> и ставлю пакеты оттуда.
Пакеты следующие:</p>

<pre><code>- cairo-freeworld
- freetype-infinality
- libXft-freeworld
- fonts-config
</code></pre>

<p>Начиная примерно с альфа-версии Fedora 15, приходится не ставить совсем cairo-freeworld, иначе Иксы просто не запускаются. Как я понимаю, не совместимость с
нынешним Xorg. Соответственно, внешний вид становится немного другим, но тоже вполне себе пригодный :)</p>

<p>А вчера столкнулся с тем, что некоторые документы при попытке открытия с
помощью Writer просто рушили как OpenOffice, так и LibreOffice. Проверял и на
том, и на другом. Долго не мог понять, что происходит, пока не посмотрел в
логи. Оказалось, офисный пакет падал с руганью на libfreetype. Уж не знаю, что
не нравилось именно в этом конкретном документе, но после удаления freetype-infinality все стало нормально.</p>

<p>Получается несколько странная ситуация, с которой я сталкивался при
использовании OpenSUSE. Там многие полезные пакеты собираются в OBS. Но порой
авторы этих сборок при выходе новой версии дистрибутива то ли забывают
поддерживать далее свое творение, то ли просто не хотят. Я понимаю, что они и
не обязаны делать это, но эффект получается неприятным. В данной ситуации
происходит нечто подобное. Последние версии пакетов в репозитории относятся
еще к октябрю-ноябрю прошлого года. Сейчас же пошла вторая половина апреля. И
пока приходится искать какие-то способы обойти проблемные места. Но чувствую,
что вся надежда на <a href="http://tigro.info/wp/">Tigro</a> :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spacewalk. Intro]]></title>
    <link href="http://hrafn.me/articles/spacewalk-intro"/>
    <updated>2011-01-24T15:45:53+03:00</updated>
    <id>http://hrafn.me/articles/spacewalk-intro</id>
    <content type="html"><![CDATA[<p><a href="https://fedorahosted.org/spacewalk/attachment/wiki/WikiStart/logo.png?format=raw"><img src="https://fedorahosted.org/spacewalk/attachment/wiki/WikiStart/logo.png?format=raw" alt="" /></a></p>

<p>Управление и котроль большого количества операционных систем не простая
задача. Spacewalk - это инструмент , позволяющий сильно упростить выполнение
этих задач. Он хранит информацию об оборудовании и программном обеспечении
систем, позволяет управлять виртуальными системами, развертывать файлы,
запускать скрипты и устанавливать программное обеспечение.</p>

<!--more-->


<p>В июне 2008 года компания Red Hat анонсировала проект Spacewalk, являющийся
open source решением для управления Linux-инфраструктурой. Spacewalk
представляет собой открытый по лицензии GPL2 продукт Red Hat Network Satellite
Server, имеющий давнюю, с 2001 года, историю разработки.</p>

<p>Вот как описывает Spacewalk <a href="http://markelov.blogspot.com">Андрей Маркелов</a>:</p>

<p>Сервер Spacewalk обслуживает весь жизненный цикл Linux-инфраструктуры и решает
следующие задачи:</p>

<ul>
<li>Сбор информации о системах (аппаратное обеспечение и установленное ПО)</li>
<li>Установка и обновление операционных систем</li>
<li>Установка и обновление программного обеспечения</li>
<li>Установка систем при помощи kickstart-файлов</li>
<li>Управление и распространение конфигурационных файлов</li>
<li>Мониторинг систем</li>
<li>Установка виртуальных машин</li>
<li>Запуск/остановка/настройка виртуальных машин</li>
<li>Работа с географически-распределенной сетью</li>
<li>Автоматизация задач системного администрирования</li>
<li>Распределение ролей администраторов и группировка систем</li>
</ul>


<p><strong>Управление программным обеспечением</strong></p>

<p>Spacewalk позволяет управлять программным обеспечением и его обновлением на
redhat-based дистрибутивах: Fedora, CentOS и Scientific Linux. Позволяет
распространять контент среди различного окружения, управлять развертыванием
обновлений на системах, а также позволяет отслеживать на какой стадии
обновления находится конкретная система в данном окружении. Простой
централизованный веб-интерфейс просматривать системы и их статус обновлений,
кроме того, инициализировать процесс обновления.</p>

<p><a href="http://spacewalk.redhat.com/img/screenshots/your_spacewalk.png"><img src="http://spacewalk.redhat.com/img/screenshots/your_spacewalk.png" alt="" /></a></p>

<p><em>Пример главной страницы Spacewalk.</em></p>

<p><strong>Другие возможности управления</strong></p>

<p>Кроме управления программным обеспечением, Spacewalk обеспечивает возможность
инициализации и мониторинга. Например, развертыват системы с помощью
kickstart-файлов, так же как и управлять и распространять файлы конфигурации
на системы. Функции мониторинга позволяет отслеживать статус систем рядом со
статусом обновлений. Spacewalk также обладает поддержкой виртуализации, что
позволяет подготавливать, контролировать, управлять и мониторить виртуальные
гостевые системы Xen.</p>

<p>Ниже я выложил еще несколько скриншотов:</p>

<p><a href="http://spacewalk.redhat.com/img/screenshots/system-overview.png"><img src="http://spacewalk.redhat.com/img/screenshots/system-overview.png" alt="" /></a><em>Обзор системы.</em></p>

<p><em><a href="http://spacewalk.redhat.com/img/screenshots/configuration-overview.png"><img src="http://spacewalk.redhat.com/img/screenshots/configuration-overview.png" alt="" /></a></em>Обзор конфигурации._</p>

<p><a href="http://spacewalk.redhat.com/img/screenshots/system-set-manager.png"><img src="http://spacewalk.redhat.com/img/screenshots/system-set-manager.png" alt="" /></a><em>System Set Manager.</em></p>

<p><a href="http://spacewalk.redhat.com/img/screenshots/kickstart_overview.png"><img src="http://spacewalk.redhat.com/img/screenshots/kickstart_overview.png" alt="" /></a><em>Обзор профиля kickstart.</em></p>

<p>Надеюсь, что из супермаленького обзора более-менее понятно, что из себя
представляет данный продукт. Процесс установки здесь и сейчас описывать не
буду. Для этого будет отдельная заметка. Лучше посмотрим другие вещи.</p>

<p>На данный момент последняя версия - 1.2. Вышла 19 ноября 2010 года. Некоторые
интересные моменты в этом релизе:</p>

<ul>
<li>некоторые страницы веб-интерфейса были переписаны с Perl на Java</li>
<li>расширена локализация</li>
<li>ограниченная поддержка PostgreSQL в качестве бэк-энда, количество операций пока ограничено</li>
<li>поддержка работы на Fedora 14</li>
<li>Fedora 12 поддерживается последний выпуск, далее поддержки не будет</li>
</ul>


<p>А вот что позволяет Spacewalk при работе с PostgreSQL:</p>

<ul>
<li>синхронизация контента с помощью satellite-sync и spacewalk-repo-sync</li>
<li>rhnpush</li>
<li>регистрация клиентов</li>
<li>работа с yum</li>
</ul>


<p>Таким образом, на данный момент возможно использование Spacewalk с PostgeSQL
для управления программным обеспечением на машине. К сожалению, полная
поддержка этой базы данных заявляет в версии 2.0. А вот что предполагается
сделать в ближайших релизах:</p>

<ul>
<li>поддержка RHEL6</li>
<li>плагин для apt-get</li>
<li>поддержка клиента Oracle 11g</li>
</ul>


<p><strong><em>Использованные ресурсы:</em></strong></p>

<ul>
<li><a href="https://fedorahosted.org/spacewalk/"><em>https://fedorahosted.org/spacewalk/</em></a></li>
<li><a href="http://markelov.blogspot.com/2008/08/spacewalk-open-source-linux.html"><em>http://markelov.blogspot.com/2008/08/spacewalk-open-source-linux.html</em></a></li>
<li><a href="http://spacewalk.redhat.com/"><em>http://spacewalk.redhat.com/</em></a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LTS или не LTS. Вот в чем вопрос...]]></title>
    <link href="http://hrafn.me/2011/01/lts-ili-ne-lts-vot-v-chem-vopros"/>
    <updated>2011-01-12T12:42:47+03:00</updated>
    <id>http://hrafn.me/2011/01/lts-ili-ne-lts-vot-v-chem-vopros</id>
    <content type="html"><![CDATA[<p>Первый раз про Russian CentOS Remix я услышал достаточно давно, уже наверно
несколько месяцев прошло. Мысли свои по этому поводу я выскажу чуть позже в
этом посте. Но на днях встретил упоминание про Remix сначала в блоге у Аркадия
Шейна (<a href="http://tigro.info/wp/?p=2100">http://tigro.info/wp/?p=2100</a>), а позже,
в этот же день, и в твиттере было обсуждение. Ссылку на обсуждение дать
затруднительно, поскольку треды в твиттере - это нечто :) Собственно, этот
пост пишется как раз по мотивам обсуждений в твиттере, а также в связи с тем,
что мне захотелось немного порассуждать о том, есть ли необходимость в
долгосрочной поддержке десктопных систем или нет, если есть, то кому это надо
и в каком виде.</p>

<!--more-->


<p>Если мне память не отказывает, то фактически долгосрочная поддержка
дистрибутивов на данный момент присутствует у Novell (SLES &amp; SLED), Canonical
(Ubuntu) и Red Hat. В связке с последним идет и CentOS, пересобирающий пакеты
от них. Стоит уточнить, что я не рассматриваю именно платную поддержку или
что-то подобное. Здесь имеется ввиду, по большей части, не платность или
бесплатность, а выпуск обновлений для продуктов. К числу дистрибутивов,
которые фактически являются долгосрочноподдерживаемыми, я бы причислил и
Debian, в основном за счет того, что выпускается в данное время по готовности,
и время между выпусками достаточно приличное, хотя и сильно меньше, чем у
других. Спорить о том, какая из систем поддерживается дольше и поддержку какой
из систем реально можно считать долгосрочной, я не буду. Разговор-то все же не
о том.</p>

<p>Я некоторое время использовал на своем десктопе, а позже и ноутбуке, SLED10 и
SLED11 от Novell. Да, многих веще не хватало, поскольку в первую очередь
данная система предназначена все же корпоративных пользователей. Однако
основные требующиеся мне пакеты там присутствовали, проблема была только с
поддержкой мультимедиа. Которая решалась подключением сначала репозиториев от
openSUSE, что неправильно, а потом репозитория от стороннего человека. К
сожалению, ссылки я сейчас не нашел, позже, если удастся найти - выложу. На
мой взгляд, система работала стабильнее, чем openSUSE, собственно по этой
причине она и была выбрана. Стоимость годовой поддержки и он-лайн доступа к
обновлениям достаточно невелика - порядка 1500 рублей на тот момент.</p>

<p>После моего перехода на redhat-based дистрибутивы я пробовал использовать
RHEL5 Desktop и CentOS на ноутбуке. Ммм, впечатления странные, честно говоря.
С одной стороны, недостаток опыта работы с ними на тот момент, с другой
стороны - откровенно устаревшее программное обеспечение, к которому привыкнуть
после SLED11 и Fedora было достаточно тяжело. Однако, мне известны люди,
которые используют CentOS в качестве десктопной системы и вполне довольны. Да
и сам я на Центе ни разу не встречал случаи неудачной загрузки после
обновления ядра, например, с которыми я сталкивался на Fedora.</p>

<p>Данный пост пишется с ноутбука, работающего под RHEL6 Desktop. И он устраивает
мне более чем полностью :) Не хватает пока репозитория RPMFusion для шестой
версии RHEL, но надеюсь, что он вскоре появится. Вопросы мультимедиа решаются
подключением дополнительных репозиториев, которых достаточно для комфортной
работы.</p>

<p>С Ubuntu я сталкивался неоднократно. Был период, когда я работал именно в этой
системе. Да и сейчас я периодически, после выхода новых версий, смотрю, что
нового появилось и каковы изменения. На мой взгляд, LTS-релизы Ubuntu, кроме
увеличенного срока поддержки, ни чем особо не отличаются от всех остальных
релизов. Хотя иногда складывается впечатление, что они, как ни странно,
получаются менее стабильными, чем обычные. Честно говоря, мне практически
неизестны люди, использующие именно Ubuntu LTS для десктопа.</p>

<p>Дебиан. Про Дебиан мне сказать практически нечего. Стабильные версии
используются, в основном, для серверов, но есть несколько известным мне людей,
которые именно стабильные релизы Дебиана используют для своего повседневного
использования. Устаревшие приложения их не пугают, поскольку от системы
требуется именно стабильность и конечный результат работы, а не новые функции
и свежее программное обеспечение.</p>

<p>Получился такой краткий обзорчик того, что я сам использовал на ноутбуке :) А
теперь поговорим собственно о самой теме. На примере CentOS.</p>

<p>Так нужен ли дистрибутив с продолжительным сроков выпуска обновлений
программного обеспечения в десктопном варианте? Я считаю, что нужен. Как
минимум, нужен мне. Поскольку удобно, стабильно и предсказуемо.</p>

<p>Нужен ли аналог Russian Fedora Remix, но только для CentOS? По мне - так
нужен. Когда я впервые прочитал про возможность такого варианта, мне это не
понравилось. Увеличенный срок поддержки добавляет нагрузку, поскольку придет
время, когда будет необходимо поддерживать сразу две, а потом и три версии
дистрибутива, если следовать срокам поддержки от Red Hat и CentOS. Кроме того,
не было никакой информации о том, что именно будет изменено в Russian CentOS
Remix, а для серверного использования мне изменения видеть не хотелось бы. Тут
важна совместимость с Red Hat.</p>

<p>Сейчас же мое мнение изменилось. В основном, по причине того, что изменения,
которые, я думаю, будут сделаны, касаются в целом десктопного варианта
использования системы: мультимедиа и исправление глупых ошибок, как написал
<a href="http://twitter.com/#!/atigro/status/24544772127457281">@atigro</a>. Если в итоге
это будет сделано по аналогии с RFR, но такой вариант пожалуй нужен даже
гораздо больше, чем сам RFR, уж пусть простят меня пользователи Русской Федоры
:)</p>

<p>Пока у меня еще была работа :), мне несколько раз приходилось решать, какой из
дистрибутивов Linux предложить для установки на обычные десктопные машины для
клиентов. В тот момент CentOS для десктопов я даже не рассматривал, по разным
причинам. И большие затраты по времени по настройке различных вещей для
нормального десктопного использования, включая мультимедиа, приведение
рабочего стола и шрифтов в приличный вид и т.д. Да, можно сделать свою
собственную сборку дистрибутива и устанавливать уже ее, но тут есть некоторые
моменты, которые заставили отказаться от этой идеи: затраты на дальнейшую
поддержку своей версии в актуальном состоянии плюс мой возможный уход на
другое место работы и соответственно опять-таки поддержка всего этого добра. В
итоге была выбрана Ubuntu, как наиболее приспособленный вариант для десктопа
по умолчанию.</p>

<p>Во время обсуждения в твиттере высказывалось мнение, что обновления
программного обеспечения для, например, секретарши не нужны совсем. На мой
взгляд, это слегка неверное мнение. Все-таки обновления приносят не только
расширение возможностей для приложений, но и исправляют ошибки, которые не
зависят от того, секретарша ли сидит на компьютером или кто-то другой :) И
исправлять их нужно. Поскольку на глазок определять, где может всплыть ошибка,
тяжело и бессмысленно. Посему, обновления нужны в любом случае.</p>

<p>Клиенты на моей бывшей работе не хотели платить лишние деньги за ОС,
устанавливаемые на рабочие машины. В основном, ради этого переход на Linux и
осуществлялся, поэтому дистрибутивы с платной поддержкой - SLE* и Red Hat - не
рассматривались. Как я уже написал ранее, была выбрана Ubuntu. Скажем так, я
был вынужден принять это решение, поскольку альтернативы предложить я не мог.
Про CentOS в нынешнем виде я уже тожу упоминал, хотя, при возможности, я бы
предпочел именно его, поскольку все сервера на CentOS и поддерживать единую
инфраструктуру сильно проще. Но Russian CentOS Remix на тот момент еще не было
:) Да и сейчас пока нет. Но очень хочется, чтобы было&#8230;</p>

<p>Сейчас перечитал написанное. Да уж, сумбурно, не совсем по теме местами, да и
конкретных доводов нет. Согласен. Это все моя ИМХА :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RHCSA]]></title>
    <link href="http://hrafn.me/2010/12/rhcsa"/>
    <updated>2010-12-30T12:43:56+03:00</updated>
    <id>http://hrafn.me/2010/12/rhcsa</id>
    <content type="html"><![CDATA[<p>На днях получил очередное письмо от Red Hat :) Теперь уже с сообщением, что в
связи с изменением программы сертификации, начиная с Red Hat Enterprise 6,
изменяется и мой сертификат. Вот он:</p>

<p><a href="http://hrafn.me/media/images/2010/12/30/rhcsa_hrafn.png"><img src="http://hrafn.me/media/images/2010/12/30/rhcsa_hrafn.png" alt="" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[openSUSE и шрифты. Окончание]]></title>
    <link href="http://hrafn.me/2010/12/opensuse-i-shrifty-okonchanie"/>
    <updated>2010-12-25T17:01:59+03:00</updated>
    <id>http://hrafn.me/2010/12/opensuse-i-shrifty-okonchanie</id>
    <content type="html"><![CDATA[<p>Что ж, похоже я получил максимум того, чего можно было добиться на данный
момент, без самостоятельного накладывания патчей и пересборки пакетов. Тот,
кто читал мои предыдущие сообщения о разборках со шрифтами, должен знать, что
мне очень полюбились патчи от <a href="http://www.infinality.net/blog/">infinality.net</a><a href="infinality.net"> </a>:)
Поскольку дают максимально комфортный для меня результат. Для openSUSE
доступен пакет freetype именно с этими патчами. Итак, приступим.</p>

<!--more-->


<p>Открываем консоль и пишем от рута:</p>

<pre><code>    # cd /etc/zypp/repos.d
    # wget http://download.opensuse.org/repositories/home:/anshuljain:/infinality/openSUSE_11.3/home:anshuljain:infinality.repo
    # zypper in freetype2-feature-subpixel-hinting
</code></pre>

<p>После установки пакетов скачиваем файл local.conf (<a href="http://www.infinality.net/files/local.conf">http://www.infinality.net/files/local.conf</a>) и помещаем его
в /etc/fonts/. Перегружаемся.</p>

<p>Результат установки пакетов можно видеть ниже. Первый скриншот - шрифты по
умолчанию, второй - после установки пропатченного freetype2.</p>

<p><a href="http://hrafn.me/media/images/2010/12/25/1.png"><img src="http://hrafn.me/media/images/2010/12/25/1.png" alt="" /></a></p>

<p><a href="http://hrafn.me/media/images/2010/12/25/2.png"><img src="http://hrafn.me/media/images/2010/12/25/2.png" alt="" /></a></p>

<p>После загрузки поиграйтесь со шрифтами. Ранее использованный мною Droid в
данной случае оказался не самым удачным вариантом. Лучше всех выглядел
Liberation :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fedora 14. Ошибка при создании виртуальной машины]]></title>
    <link href="http://hrafn.me/2010/12/fedora-14-oshibka-pri-sozdanii-virtualnoj-mashiny"/>
    <updated>2010-12-02T15:56:18+03:00</updated>
    <id>http://hrafn.me/2010/12/fedora-14-oshibka-pri-sozdanii-virtualnoj-mashiny</id>
    <content type="html"><![CDATA[<p>Решил я еще раз попробовать привести шрифты в openSUSE в нормальный вид.
Ставить на ноут будучи неуверенным, что все получится до конца и завершится
удачно, у меня не было, надумал поставить дистр в виртуалке.</p>

<!--more-->


<p>Поскольку KVM я
люблю и не люблю Virtualbox, но его и выбрал :) Создаю виртуалку, выбираю
всякие-разные опции и в итоге получаю такое:</p>

<pre><code>    Uncaught Error: Не удалось завершить установку: 'Unable to deny all devices for opensuse: No such file or directory
    Traceback (most recent call last):
    File "/usr/share/virt-manager/virtManager/create.py", line 1567, in do_install
    dom = guest.start_install(False, meter = meter)
    File "/usr/lib/python2.7/site-packages/virtinst/Guest.py", line 1023, in start_install
    return self._do_install(consolecb, meter, removeOld, wait)
    File "/usr/lib/python2.7/site-packages/virtinst/Guest.py", line 1088, in _do_install
    "install")
    File "/usr/lib/python2.7/site-packages/virtinst/Guest.py", line 1059, in _create_guest
    dom = self.conn.createLinux(start_xml, 0)
    File "/usr/lib64/python2.7/site-packages/libvirt.py", line 1277, in createLinux
    if ret is None:raise libvirtError('virDomainCreateLinux() failed', conn=self)
    libvirtError: Unable to deny all devices for opensuse: No such file or directory
</code></pre>

<p>Я считаю: &#8220;Восхитительно!&#8221; Особенно меня радует понятность описания проблемы и
легкость поиска решения проблемы. Впрочем, virt-manager этим отличался всегда.
Если кто-то столкнется с таким же чудом, то должно помочь следующее:</p>

<pre><code>    # /etc/init.d/cgconfig start
</code></pre>

<p>или</p>

<pre><code>    # service cgconfig start
</code></pre>

<p>поскольку libvirt не может найти правил для новой виртуальной машины.</p>

<p>Единственно, что мне не понятно, почему разработчики Fedora не сделали
проверку при создании виртуальной машины: запущена ли эта служба или нет. К
тому же, cgroup сейчас не настолько широко развита и далеко не на всех дистрах
так широко используется, чтобы запуск ее стал очевидным решением.</p>

<p>Ладно, не сделали и не сделали. В любом случае, дабы избежать таких проблем в
дальнейшем, либо перед запуском виртуальной машины запускайте службу руками,
либо же добавьте ее в автозагрузку при помощи ntsysv или chkconfig.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Управление пакетами в RHEL6. Yum]]></title>
    <link href="http://hrafn.me/articles/package-management-in-rhel6-yum"/>
    <updated>2010-11-30T11:18:40+03:00</updated>
    <id>http://hrafn.me/articles/package-management-in-rhel6-yum</id>
    <content type="html"><![CDATA[<p>Yum - это менеджер пакетов Red Hat, который умеет запрашивать информацию о
пакетах, получать пакеты из репозиториев, устанавливать и удалять их,
используя автоматическое разрешение зависимостей, а также обновлять целиком
систему до последних версий пакетов. Yum выполняет автоматическое разрешение
зависимостей для пакетов, которые обновляются, устанавливаются или удаляются,
и, таким образом, позволяет автоматически определять, получать и устанавливать
все доступные по зависимостям пакеты. Для Yum можно настроить ноые,
дополнительные репозитории, или, по другому, источники пакетов, кроме того,
для него доступны многие дополнения, которые улучшают и расширяют его
возможности. Yum позволяет выполнять многие из задач, которые выполняет RPM;
кроме того, многие из опции командной строки у него также подобны. Yum
обеспечивает простое и легкое управление пакетами на одной машине или же на
группе машин.</p>

<!--more-->


<p>====================================================================</p>

<p><strong>Важно</strong></p>

<p><em>Безопасное управление пакетами с помощью подписей GPG</em></p>

<p>Yum обеспечивает безопасное управление пакетами путем включения проверки
сигнатур GPG для пакетов, подписанных с помощью GPG, дл всех репозиториев
пакетов или для отдельных репозиториев. В случае включения проверки сигнатур,
Yum откажется устанавливать любые пакеты, не подписанные корректным ключом для
данного репозитория. Это означает, что можно доверять пакетам RPM, которые
скачиваются и устанавливаются на машине в том случае, если они получены из
доверенных источников, например, Red Hat, и они не были изменены в процессе
передачи.</p>

<p>====================================================================</p>

<p>Yum также позволяет легко создавать собственные репозитории RPM-пакетов для
скачивания и установки их на других машинах.</p>

<p>Изучение Yum - стоящее вложение, поскольку это часто наиболее быстрый способ
выполнения задач по системному администрированию, и Yum обеспечивает
возможности, превышающие таковые, предлагаемые графическими инструментами
управления пакетами PackageKit.</p>

<h2>1.1 Проверка обновлений и обновление пакетов</h2>

<h3>1.1.1 Проверка наличия обновлений</h3>

<p>Вы можете использовать команду <code>yum check-update</code> для просмотра доступных
обновлений для вашей системы.</p>

<p>=========================================================</p>

<p><strong>Заметка</strong></p>

<p>Yum и привилегии суперпользователя !!!</p>

<p>Необходимо иметь права суперпользователя, чтобы использовать yum для
установки, обновления или удаления пакетов. Все примеры в этом разделе
подразумевают, что права суперпользователя уже получены с помощью команд su
либо sudo.</p>

<p>=========================================================</p>

<pre><code>    # yum check-update
    Loaded plugins: presto, refresh-packagekit, security
    PackageKit.x86_64                  0.5.8-2.el6                rhel
    PackageKit-glib.x86_64             0.5.8-2.el6                rhel
    PackageKit-yum.x86_64              0.5.8-2.el6                rhel
    PackageKit-yum-plugin.x86_64       0.5.8-2.el6                rhel
    glibc.x86_64                       2.11.90-20.el6             rhel
    glibc-common.x86_64                2.10.90-22                 rhel
    kernel.x86_64                      2.6.31-14.el6              rhel
    kernel-firmware.noarch             2.6.31-14.el6              rhel
    rpm.x86_64                         4.7.1-5.el6                rhel
    rpm-libs.x86_64                    4.7.1-5.el6                rhel
    rpm-python.x86_64                  4.7.1-5.el6                rhel
    udev.x86_64                        147-2.15.el6               rhel
    yum.noarch                         3.2.24-4.el6               rhel
</code></pre>

<p>Все перечисленные пакеты имеют доступные обновления. Первый пакет в списке -
PackageKit, графический менеджер пакетов. Первая строка вывода говорит вот о
чем:</p>

<ul>
<li><strong>PackageKit</strong> - имя пакета</li>
<li><strong>х86_64</strong> - архитектура процессора, под которую пакет был собран</li>
<li><strong>0.5.8</strong> - версия обновленного пакета, который будет установлен</li>
<li><strong>rhel</strong> - репозиторий, в котором обновленный пакет расположен</li>
</ul>


<p>В выводе также показано, что можно обновить ядро, сам Yum и RPM, а также как и
их зависимости (kernel-firmware, rpm-libs и rpm-python), используя yum.</p>

<h3>1.1.2 Обновление пакетов</h3>

<p>Для обновления можно выбрать одиночный пакет, множество пакетов или же все
пакеты сразу. Если какие-либо зависимости пакетов, выбранных для обновления,
сами имеют более свежие версии, они также будут обновлены. Для обновления
одного пакета введите команду yum update &lt;имя_пакета>:</p>

<pre><code>    # yum update udev
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    Setting up Update Process
    Resolving Dependencies
    --&gt; Running transaction check
    ---&gt; Package udev.x86_64 0:147-2.15.el6 set to be updated
    --&gt; Finished Dependency Resolution
    Dependencies Resolved
    ===========================================================================
    Package       Arch            Version                 Repository     Size
    ===========================================================================
    Updating:
    udev          x86_64          147-2.15.el6            rhel          337 k
    Transaction Summary
    ===========================================================================
    Install       0 Package(s)
    Upgrade       1 Package(s)
    Total download size: 337 k
    Is this ok [y/N]:
</code></pre>

<p>вывод содержит несколько интересных вещей:</p>

<ol>
<li><strong>Loaded plugins: presto, refresh-packagekit, rhnplugin, security</strong> - yum всегда сообщает, какие дополнения установлены и включены. В данном случае, yum использует дополнения presto, refresh-packagekit и security.</li>
<li><strong>kernel.x86_64</strong> - вы можете безопасно скачать и установить новые ядра.</li>
</ol>


<p>===========================================================</p>

<p><strong>Заметка</strong></p>

<p><em><em>Обновление и установка ядра с помощью Yum</em></em></p>

<p>yum всегда УСТАНАВЛИВАЕТ новое ядро, подобно тому, как RPM устанавливает новое
ялро с помощью команды <code>rpm -i kernel</code>. Другими словами, нет необходимости
беспокоиться о разнице между установкой и обновлением пакета ядра при
использовании yum: все будет сделано правильно независимо от того,
используется ли команда <code>yum update</code>, или же <code>yum install</code>.</p>

<p>С другой стороны, при использовании RPM, важно использовать команду <code>rpm -i kernel</code> (которая установит новое ядро) вместо <code>rpm -u kernel</code> (которая заместит
текущее ядро).</p>

<p>===========================================================</p>

<ol>
<li>yum показывает информацию об обновлени, а затем делает запрос о необходимости выполнить обновление; yum по умолчанию работает в интерактивном режиме. Если заранее известно, какие транзакции yum планирует выполнить, можно использовать опцию -y, которая автоматически отвечает yes на все вопросы, которые yum может задать (в этом случае он запускается не-интерактивно). Как бы то ни было, всегда можно проверить, какие изменения yum планирует произвести в системе, поэтому можно легко разрешить любую проблемы, которая может возникнуть. Если транзакция прошла неправильно, можно посмотреть лог транзакции с помощью команды <code>cat /var/log/yum.log</code>. Самые последние транзакции представлены в конце файла.</li>
</ol>


<p><em>Обновление всех пакетов и их зависимостей</em></p>

<p>Для обновления всех пакетов и их зависимостей просто введите <code>yum update</code> (без
аргументов):</p>

<pre><code>    # yum update
</code></pre>

<h3>1.1.3 Обновление пакетов, связанное с безопасностью</h3>

<p>Выяснение, какие пакеты имеют обновления, связанные с безопасностью, и
установка таких обновлений бытсро и легко - очень важно. Для этой цели Yum
предлагает отдельное дополнение. Плагин security расширяет команду yum с
помощью набора очень полезных команд, подкоманд и опции, ориентированных на
безопасность.</p>

<h3>1.1.4 Изменение сохраненных конфигурационных файлов</h3>

<p>Установленные пакетами файлы конфигурации будут неизбежно изменены в процессе
эксплуатации Red Hat Enterprise Linux. RPM, который Yum использует для
выполнения изменений в системе, предоставляет механизм для гарантии своей
сохранности.</p>

<h2>1.2 Пакеты и группы пакетов</h2>

<h3>1.2.1 Поиск, перечисление и отображение информации о пакете</h3>

<p>Можно искать пакеты по имени, подписи и описанию, используя команду yum search
&lt;выражение>. yum отобразит список соответствий для каждого выражения.</p>

<pre><code>    # yum search meld kompare
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    ============================ Matched: kompare =============================
    kdesdk.x86_64 : The KDE Software Development Kit (SDK)
    Warning: No matches found for: meld
</code></pre>

<p>yum search полезен для поиска пакетов, имя которых неизвестно, но известно к
чему они относятся.</p>

<p><strong>Перечень пакетов</strong></p>

<p><code>yum list</code> и связанные с ним команды предоставляет информацию о пакетах, группах
пакетов и репозиториях.</p>

<p>=============================================================</p>

<p><strong> Полезно </strong></p>

<p><em>Фильтрация результатов с помощью регулярных выражений</em></p>

<p>Все различные команды Yum позволяют фильтровать результаты путем добавления
одного и нескольких регулярных выражений в качестве аргументов. Глобальные
выражения - это обычная строка символов, которые содержат один или множество
wildcard-символов * (кототый соответветствует нескольким любым символам) и ?
(который соответствует одному любому символу). Необходимо использовать
экранирование обеих символов для передачи их в качестве аргумента команде yum.
Если это не сделать, bash будет интерпретировать глобальное выражение в
качестве расширения имени пути, и потенциально передаст все файлы в текущей
директории в качестве соответствия команде yum, но это не то, что требуется.
Напротив, необходимо передать сами регулярные выражения yum, что можно сделать
следующим образом:</p>

<ul>
<li>экранируя сиволы</li>
<li>заключить выражение целиком в двойные или одинарные ковычки</li>
</ul>


<p>В следующих примерах показаны оба способа:</p>

<pre><code>    # yum list available gstreamer\*plugin\*
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    Available Packages
    gstreamer-plugins-bad-free.i686               0.10.17-4.el6            rhel
    gstreamer-plugins-base.i686                   0.10.26-1.el6            rhel
    gstreamer-plugins-base-devel.i686             0.10.26-1.el6            rhel
    gstreamer-plugins-base-devel.x86_64           0.10.26-1.el6            rhel
    gstreamer-plugins-good.i686                   0.10.18-1.el6            rhel

    # yum list installed "krb?-*"
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    Installed Packages
    krb5-libs.x86_64                         1.8.1-3.el6                  @rhel
    krb5-workstation.x86_64                  1.8.1-3.el6                  @rhel
</code></pre>

<p>===============================================================</p>

<p><strong>- yum list &lt;регулярное_выражение></strong> - показывает информацию об установленных или доступных пакетах, соответствующих регулярному выражению.</p>

<pre><code>    # yum list abrt-addon\* abrt-plugin\*
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    Installed Packages
    abrt-addon-ccpp.x86_64                        1.0.7-5.el6             @rhel
    abrt-addon-kerneloops.x86_64                  1.0.7-5.el6             @rhel
    abrt-addon-python.x86_64                      1.0.7-5.el6             @rhel
    abrt-plugin-bugzilla.x86_64                   1.0.7-5.el6             @rhel
    abrt-plugin-logger.x86_64                     1.0.7-5.el6             @rhel
    abrt-plugin-sosreport.x86_64                  1.0.7-5.el6             @rhel
    abrt-plugin-ticketuploader.x86_64             1.0.7-5.el6             @rhel
</code></pre>

<p><strong>- yum list all</strong> - список всех установленных И доступных пакетов
<strong> - yum list installed</strong> - список всех пакетов, установленных в системе. Колонка с правой стороны показывает репозиторий, из которого пакет был получен.<br/>
<strong> - yum list available</strong> - список всех доступных пакетов во всех включеных репозиториях<br/>
<strong> - yum grouplist</strong> - список всех групп пакетов<br/>
<strong> - yum repolist</strong> - список ID репозиториев, имя и количество пакетов, которые предоставлены для каждого включенного репозитория.</p>

<p><strong>Отображение информации о пакете</strong><br/>
<strong> yum info &lt;имя_пакета> </strong>отображает информацию об одном или множестве пакетов (регулярные выражения в данном случае также работают):</p>

<pre><code>    # yum info abrt
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    Installed Packages
    Name       : abrt
    Arch       : x86_64
    Version    : 1.0.7
    Release    : 5.el6
    Size       : 578 k
    Repo       : installed
    From repo  : rhel
    Summary    : Automatic bug detection and reporting tool
    URL        : https://fedorahosted.org/abrt/
    License    : GPLv2+
    Description: abrt is a tool to help users to detect defects in applications
    : and to create a bug report with all informations needed by
    : maintainer to fix it. It uses plugin system to extend its
    : functionality.
</code></pre>

<p><code>yum info &lt;имя_пакета&gt;</code> аналогично команде <code>rpm -q --info &lt;имя_пакета&gt;</code>, но
предоставляет в качестве дополнительной информации ID репозитория Yum, в
котором пакет найден (взгляните на строку From repo: в выводе).</p>

<p><code>yumdb info &lt;имя_пакета&gt;</code> может быть использован для запроса к базе данных Yum
для получения альтернативной и полезной инормации о пакете, включая
контрольную сумму пакета (и алгоритм, использующийся для ее создания,
например, SHA-256), команды, набранной в командной строке, вызванной для
установки пакета и причины, по которым пакет был установлен в системе (где
user означает, что он был установлен пользователем, а dep - что был установлен
в качестве зависимости:</p>

<pre><code>    # yumdb info yum
    yum-3.2.27-4.el6.noarch
    checksum_data = 15c8eaf583fabad6974a35b9f6c6527e49362fe4e23baec1682ef51a598e4abb
    checksum_type = sha256
    command_line = update
    from_repo = rhel
    from_repo_revision = 1271991599
    from_repo_timestamp = 1271991721
    reason = user
    releasever = 6
</code></pre>

<p>Смотрите man yumdb для получения более подробной информации о команде yumdb.</p>

<p>И наконец, команда <strong>yum history</strong>, новая для Red Hat Enterprise Linux 6,
может быть использована для показа временных отметок транзакций Yum, даты и
времени, когда они произошли, количество неисправных пакетов, были ли
транзакции успешными или были прерваны, и изменилась ли база данных RPM между
транзакциями. Обратитесь к разделу history в man yum за подробностями.</p>

<h3>1.2.2 Установка</h3>

<p>Можно установить пакет и все его неустановленные зависимости введя:</p>

<pre><code>    # yum install &lt;имя_пакета&gt;
</code></pre>

<p>Можно установить множество пакетов одновременно, добавив их имена как
аргументы.</p>

<p>Если устанавливаются пакеты на многобиблиотечной системе, например, AMD64 или
Intel64, можно указать архитектуру пакета, добавив .arch к имени пакета:</p>

<pre><code>    # yum install sqlite2.i586
</code></pre>

<p>Можно использовать регулярные выражения для быстрой установки пакетов с
похожими именами:</p>

<pre><code>    # yum install audacious-plugins-\*
</code></pre>

<p>В дополнение к имени пакета и регулярному выражению можно предоставить команде
yum имя файла. Если известно имя бинарного файла для установки, но не известно
имя пакета, можно дать просто пусть:</p>

<pre><code>    # yum install /usr/sbin/named
</code></pre>

<p>yum, при поиске по списку пакетов, найдет пакет, который предоставляет <code>/usr/sbin/named</code>, если он есть, и спросит подтверждения установки.</p>

<p>Что делать, если необходимо установить пакет, который содержит бинарный файл
named, но непонятно, в какой директории, /bin или /sbin, этот файл находится?
В этой ситуации, можно передать yum provides глобальное выражение:</p>

<pre><code>    # yum provides "*bin/named"
    Loaded plugins: presto, refresh-packagekit, rhnplugin, security
    32:bind-9.7.0-4.P1.el6.x86_64 : The Berkeley Internet Name Domain (BIND)
    : DNS (Domain Name System) server
    Repo        : rhel
    Matched from:
    Filename    : /usr/sbin/named
    ~]# yum install bind
</code></pre>

<p>===========================================================</p>

<p><strong> Заметка </strong></p>

<p><code>yum provides</code> подобен <code>yum whatprovides</code></p>

<p>===========================================================</p>

<p><strong> Полезно </strong></p>

<p>yum provides/whatprovides и глобальные выражения</p>

<p><code>yum provides "*/&lt;имя_файла&gt;"</code> - общий и полезный хак для быстрого поиска пакета, содержащего указанное имя файла</p>

<p>===========================================================</p>

<p><strong>Установка группы пакетов</strong></p>

<p>Группа пакетов подобна пакету: она не используется сама по себе, но ее
установка тащит группу зависимых пакетов, которые обеспечивают конечный
результат. Группа пакетов имеет имя и ID группы. Команда yum grouplist -v
показывает имена всех групп пакетов и, один за другим, ID группы в круглых
скобках. ID группы это всегда термин в паре круглых скобок, например, как kde-
desktop и kde-software-development в этом примере:</p>

<p>===========================================================</p>

<p><strong>  Внимание </strong></p>

<p>Не все пакеты, использующиеся в примерах, доступны в RHN.</p>

<p>Некоторые из пакетов - или групп пакетов - запрашиваемые и установленные с
помощью Yum в этом разделе могут быть не доступны в Red Hat Network. Их
использование в этих примерах - просто демонстрация работы Yum. Заметьте, что
получение и установка программного обеспечения из пепроверенных или
недоверенных источников, отличных от Red Hat Network, может привести к рискам
и проблемам безопасности, стабильности и совместимости.</p>

<p>===========================================================</p>

<pre><code>    # yum -v grouplist kde\*
    KDE (K Desktop Environment) (kde-desktop)
    KDE Software Development (kde-software-development)
</code></pre>

<p>Можно установить группу пакетов путем передачи ее полного имени (без ID
группы) команде groupinstall:</p>

<pre><code>    # yum groupinstall "KDE (K Desktop Environment)"
</code></pre>

<p>Также можно установить с помощью ID группы:</p>

<pre><code>    # yum groupinstall kde-desktop
</code></pre>

<p>Точно также передается ID группы (или имя в ковычках) команде install, если
предварить его символов &#8220;@&#8221; (который говорит yum, что необходимо выполнить
groupinstall):</p>

<pre><code>    # yum install @kde-desktop
</code></pre>

<h3>1.2.3 Удаление</h3>

<p>yum remove &lt;имя_пакета> деинсталлирует пакет, также как и пакеты, которые от
него зависят. Как можно устанавливать несколько пакетов за раз, так можно и
удалять их так же:</p>

<pre><code>    # yum remove foo bar baz
</code></pre>

<p>Подобно install, remove может принимать такие же аргументы:</p>

<ul>
<li>имена пакетов</li>
<li>глобальные выражения</li>
<li>списки файлов</li>
<li>предоставленные пакеты</li>
</ul>


<p>===========================================================</p>

<p><strong> Внимание </strong></p>

<p>Удаление пакета в том случае, когда другие пакеты зависят от него</p>

<p>Yum не может удалить пакет, не удаляя при этом пакеты, крые зависят от него.
Этот тип операции может быть выполнен с помощью RPM, но не рассматривается, и
потенциально может привести систему в неработоспособное состояние или же
послужить причиной странного поведения приложений или же их краха.</p>

<p>===========================================================</p>

<p><strong>Удаление группы пакетов</strong></p>

<p>Можно удалить группу пакетов, используя синтаксис, соответствующий синтаксису
install.</p>

<pre><code># yum groupremove "KDE (K Desktop Environment)"
~]# yum groupremove kde-desktop
~]# yum remove @kde-desktop
</code></pre>

<p>===========================================================</p>

<p><strong> Важно </strong></p>

<p><em>Умное удаление группы пакетов</em></p>

<p>Когда вы говорите yum удалить группу пакетов, он удалит каждый пакет в этой
группе, даже если эти пакеты являются членами другой группы пакетов или
зависимостями для других установленных пакетов. Как бы то ни было, yum можно
указать удалять только те пакеты, которые не требуются каким-либо другим
пакетам или группам, добавив директиву <code>groupremove_leaf_only=1</code> в секцию [main]
файла /etc/yum.conf.</p>

<p>===========================================================</p>

<h2>1.3 Настройка Yum и репозиториев</h2>

<p>В этом разделе показано, как:</p>

<ul>
<li>установить глобальные опции Yum, отредактировав сецию [main] в файле конфигурации /etc/yum.conf</li>
<li>установить опции для отдельных репозиториев, отредактировав секции [repository] в /etc/yum.conf и файлы <code>.repo</code> в каталоге /etc/yum.repos.d/</li>
<li>использовать переменные Yum в /etc/yum.conf и файлы в /etc/yum.repos.d/ так, чтобы динамические значения версий и архитектуры обрабатывались корректно</li>
<li>настроить ваш собственный репозиторий Yum</li>
</ul>


<p>Файл конфигурации /etc/yum.conf содержит одну обязательную секцию [main], в
которой можно установить опции Yum. Значения, определенные в этой секции имеют
глобальный эффект, и могут быть переопределены значениями, установленными в
конкретной секции [repository]. Также можно добавлять секции [repository] в
/etc/yum.conf, однако, гораздо лучше определять отдельные репозитории в новом
или существующем файле .repo в каталоге /etc/yum.repos.d/.</p>

<h3>1.3.1 Установка опций [main]</h3>

<p>Файл /etc/yum.conf содержит ровно одну секцию [main]. Можно добавлять
дополнительные опции в эту секцию в начале /etc/yum.conf. Некоторые из пар
ключ-значение в этой секции влияют на то, как будет действовать yum; другие
влияют на работу репозиториев. Лучшим источником информации по всем опциям Yum
является разделы [main] OPTIONS и [repository] OPTIONS в man yum.conf.</p>

<p>Ниже показан пример файла конфигурации /etc/yum.conf:</p>

<pre><code>    [main]
    cachedir=/var/cache/yum/$basearch/$releasever
    keepcache=0
    debuglevel=2
    logfile=/var/log/yum.log
    exactarch=1
    obsoletes=1
    gpgcheck=1
    plugins=1
    installonly_limit=3
    [comments abridged]
    # PUT YOUR REPOS HERE OR IN separate files named file.repo
    # in /etc/yum.repos.d
</code></pre>

<p>Далее приведен список наиболее часто использующихся опций в секции [main] и
описание каждой их них:</p>

<p><strong>assumeyes=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - yum будет запрашивать подтверждение критических действий для выполнения.
Установлено по умолчанию.</p>

<p>1 - Не запрашивать подтверждение для критически важных действий. Если
установлеон это значение, yum ведет себя подобно тому, как если было бы
использовалась опция <code>-y</code>.</p>

<p><strong>cachedir=/var/cache/yum/$basearch/$releasever</strong></p>

<p>Эта опция указывает каталог, в котором Yum будет хранить свой кэш и базу
данных файлов. По умолчанию, каталог кэша <code>/var/cache/yum/$basearch/$releasever</code>.</p>

<p><strong>debuglevel=значение</strong></p>

<p>&#8230;где &lt;значение> - это число между 1 и 10. Установка высокого значения
приводит к отображению более детального вывода отладочной информации.
<code>debuglevel=0</code> отключает вывод отладки, тогда как <code>debuglevel=2</code> - значение по
умолчанию.</p>

<p><strong>exactarch=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> - одно из:</p>

<p>0 - не использовать точное значение архитектуры при обновлении пакетов</p>

<p>1 - принимать во внимание точную архитектуру при обновлении пакетов. При этой
установке yum не сможет установить пакет i686 для обновления пакета i386, уже
установленного в системе. Это занчение установлено по умолчанию.</p>

<p><strong>exclude=&lt;имя<em>пакета> [несколько</em>имен_пакетов]</strong></p>

<p>Эта опция позволяет исключить пакеты по ключевым словам из процесса
установки/обновления. Список из нескольких пакетов для исключения может быть
заключен в ковычки с пробелом в качестве разделителя списка. Позволено
использование глобальных выражений оболочки (например, * и ?).</p>

<p><strong>gpgcheck=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - отключить проверку сигнатуры GPG для пакетов из всех репозиториев, включая
локальную установку пакетов.</p>

<p>1 - Включить проверку сигнатуры GPG для всех пакетов во всех репозиториях,
включая локальную установку пакетов. gpgcheck=1 установлено по умолчанию,
таким образом, проверяются сигнатуры всех пакетов.</p>

<p>Если эта опция установлена в секции [main] в файле /etc/yum.conf, она
устанавливает правило проверки для всех репозиториев. С другой стороны, можно
также отпределить gpgcheck=&lt;значение> для конкретного репозитория; т.е. можно
включить проверку для одного репозитория, отключив при этом для другого.
Установка gpgcheck=&lt;значение> для отдельного репозитория с соответствующем
файле .repo переопределяет занчение по умолчанию, представленное в
/etc/yum.conf.</p>

<p><strong>groupremove_leaf_only=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - yum не должен проверять для каждого пакета, которые удаляется при удалении
группы пакетов. С этим значением yum удаляет все пакеты в группе пакетов, не
обращая внимания, требуются ли эти пакеты другим пакетам ли группам.
<code>groupremove_leaf_only=0</code> - это значение по умолчанию.</p>

<p>1 - yum будет проверять зависимости каждого пакета при удалении группы
пакетов, и удалит только те пакеты, которые не требуются ли какому-либо еще
пакету или группе.</p>

<p><strong>installonlypkgs=&lt;разделенный>&lt;пробелами>&lt;список>&lt;пакетов></strong></p>

<p>Здесь есть возможность предоставить разделенный пробелами список пакетов,
которые yum может установить, но никогда не будет обновлять. Обратитесь к man
yum.conf за списком всех пакетов, которые подпадают под это правило по
умолчанию. Если добавить директиву <code>installonlypkgs</code> в /etc/yum.conf, необходимо
убедиться, что перечислены все пакеты, которые будут только устанавливаться,
включая любые из перечисленных в разделе <code>installonlypkgs</code> <code>man yum.conf</code>. В
частности, пакеты ядра всегда должны быть перечислены в installonlypkgs (они
там по умолчанию) и значение <code>installonly_limit</code> должно быть всегда больше 2,
чтобы резервная копия ядра всегда была доступна, если умолчальное не сможет
загрузиться.</p>

<p><strong>installonly_limit=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> - число, определяющее максимальное количество версий,
которые могут быть установленны одновременно для любого единичного пакета,
перечисленного в директиве <code>installonlypkgs</code>. Значение по умолчанию для
директивы <code>installonlypkgs</code> включает несколько различных пакетов ядер, так что,
убедитесь, что изменение значения <code>installonly_limit</code> также повлияет на
максимальное количество установленных версий любого одного пакета ядра.
Значение по умолчанию, указанное в /etc/yum.conf - <code>installonly_limit=3</code>, и не
рекомендуется его уменьшать, особенно делать ниже 2.</p>

<p><strong>keppcache=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - не сохранять кэш заголовков и пакетов после успешной установки. Это
значение по умолчанию.</p>

<p>1 - Сохранять кэш после успешной установки.</p>

<p><strong>logfile=/var/log/yum.log</strong></p>

<p>Эта опция указавает, куда yum будет отправлять вывод логов. По умолчанию, yum
хранит информацию в /var/log/yum.log.</p>

<p><strong>multilib_policy=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>best - установить наиболее подходящую архитектуру для этой системы. Например,
установка этого значения на системе AMD64 приведет к тому, что yum установит
64-битную версии всех пакетов.</p>

<p>all - всегда устанавливать каждую возможную архитектуру для каждого пакета.
Например, при установке этого значения на системе AMD64, yum установит как
i586, так и AMD64 версии пакета, если они оба доступны.</p>

<p><strong>obsoletes=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - отключает устаревшую логику обработки при выполнении обвноления</p>

<p>1 - включает устаревшую логику обработки при выполнении обновления. Когда один
пакет заявляет в своем spec-файле, что он устарел по отношению к другому
пакету, более аоздний пакет будет замещен пакетом разработчика, если пакет
разработчика установлен. Устаревание объявляется, например, когда пакет
переименовывается. <code>obsoletes=1</code> - значение по умолчанию.</p>

<p><strong>plugins=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - Отключает все дополнения Yum глобально.</p>

<p>===========================================================</p>

<p><strong> Важно </strong></p>

<p>Отключение всех дополнений не благоразумно !!!</p>

<p>Отключение всех дополнений не благоразумно, поскольку некоторые дополнения
обеспечивают важные для Yum сервисы. В частности, rhnplugin позволяет
подключаться к Red Hat Network, а дополнение security позволяет системному
администратору легко обновлять систему с помощью (иногда критических)
обновлений безопасности. Глобальное отключение дополнений представлена в
качестве удобной опции и, в основном, рекомендуется для определения
потенциальных проблем с Yum.</p>

<p>===========================================================</p>

<p>1 - Включает все дополнения глобально. С этим значением все еще можно
отключить конкретное дополнение, установив enabled=0 в конфигурационном файле
этого дополнения.</p>

<p><strong>reposdir=</strong></p>

<p>Эта опция позволяет указать каталог, в котором будут расположены файлы .repo.
Все эти файлы содержат информацию о репозиториях (подобно секции [repository]
в файле /etc/yum.conf). yum собирает всю информацию о репозиториях из файлов
.repo и секции [repository] файла /etc/yum.conf для создания главного списка
репозиториев для использования при транзакциях. Если reposdir не установлено,
yum использует стандартный каталог /etc/yum.repos.d/.</p>

<p><strong>retries=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> - число 0 или больше. Это значение определяет количество
времени, которое yum будет пытаться полусить файл до того, как вернет ошибку.
При установке значения в 0 yum будет пытаться постоянно. Значение по умолчанию
- 10.</p>

<h3>1.3.2 Настройка опций [repository]</h3>

<p>Можно определить отдельный репозиторий, добавив секцию [repository] (где
repository - уникальный ID репозитория, например, [my_personal_repo]) в
/etc/yum.conf или в файл .repo в каталоге /etc/yum.repos.d/. Все файлы .repo в
/etc/yum.repos.d/ читаются yum; лучше всего указывать свой репозиторий именно
здесь, а не в /etc/yum.conf. Можно создать новые, отдельные файлы .repo в этом
каталоге, добавить в них секцию [repository] и при следующем запуске команды
yum вновь созданные репозитории будет добавлены.</p>

<p>Здесь показан (крайне минимальный) пример вида файла .repo:</p>

<pre><code>    [repository_ID]
    name=A Repository Name
    baseurl=http://path/to/repo или ftp://path/to/repo или file://path/to/local/repo
</code></pre>

<p>Каждая секция [repository] должна содержать следующие минимальные части:</p>

<p><strong>[repository_ID]</strong></p>

<p>repository_ID - это уникальная строка из одного слова (без пробелов, но нижнее
подчеркивание попускается) символов (заключенная в квадратные скобки), которая
указывает идентификатор репозитория.</p>

<p><strong>name=&lt;Имя моего репозитория></strong></p>

<p>В этой строке содержится понятное для человека описание этого репозитория.</p>

<p><strong>baseurl=http://path/to/repo, ftp://path/to/repo, file://path/to/local/repo</strong></p>

<p>Это пусть до каталога, в котором расположен каталог repodata этого
репозитория. Как правило, этот URL - ссылка на HTTP, например:</p>

<pre><code>    baseurl=http://path/to/repo/releases/$releasever/server/$basearch/os/
</code></pre>

<p>Yum всегда разворачивает переменные <code>$releasever</code>, <code>$arch</code> и <code>$basearch</code> в URL.</p>

<ul>
<li>если репозиторий доступен по FTP, используйте: ftp://path/to/repo</li>
<li>если репозиторий находитяс на локальной машине, используйте: file://path/to/local/repo</li>
<li><p>если указанный репозиторий требует базовую аутентификацию HTTP, можно указать имя пользователя и пароль в http://path/to/repo с помощью имя_пользователя:пароль@ссылка. Например, если репозиторий на http://www.example.com/repo/ требует имя пользователя в виде &#8220;user&#8221;, а пароль - &#8220;password&#8221;, то запись baseurl может быть следующей:</p>

<pre><code>baseurl=http://user:password@www.example.com/repo/
</code></pre></li>
</ul>


<p>Далее показана еще одна полезная директива [repository]:</p>

<p><strong>enabled=&lt;значение></strong></p>

<p>&#8230;где &lt;значение> одно из:</p>

<p>0 - не считать этот репозиторий в качестве источника пакетов при выполнении
обновления и установке. Это простейший пусть быстро включить или выключить
репозиторий, который полезен только при установке единственного пакета из
репозитория, не требующегося для обновления или установки.</p>

<p>1 - позволяет использовать этот репозиторий в качестве источника пакетов.</p>

<p>Включение или отключение репозиториев также может быть сделано путем передачи
опции либо <code>--enablerepo=</code>, либо <code>--disablerepo=</code> команде yum.</p>

<p>Существует гораздо больше опций [repository]. Обратитесь к разделу
[repository] OPTIONS man yum.conf за более подробным списком и описанием для
каждой.</p>

<h3>1.3.3 Использование переменных Yum</h3>

<p>Можно использовать и обращаться к следующим переменным в командах yum и во
всех файлах конфигурации (/etc/yum.conf и все файлы .repo в /etc/yum.repos.d/)</p>

<p><strong>$releasever</strong></p>

<p>Можно использовать эту переменную для обращения к версии релиза Red Hat
Enterprise Linux. Yum получает значение $releasever из строки
<code>distroverpkg=&lt;значение&gt;</code> в файле /etc/yum.conf. Если такой строки не
существует, yum получает корректное значение, вытаскивая номер версии из
пакета redhat-release.</p>

<p><strong>$arch</strong></p>

<p>Можно использовать эту переменную обращаясь к архитектуре процессора путем
получения значения функции Python <code>os.uname()</code>. Верные значения для $arch
включают: i586, i686 и x86_64.</p>

<p><strong>$basearch</strong></p>

<p>Можно использовать $basearch для обращения к базовой архитектуре системы.
Например, машины i686 и i586 обе имеют базовую архитектуру i386, а AMD64 и
Intel64 - соответственно x86_64.</p>

<p><strong>$YUM0-9</strong></p>

<p>Эти десять переменных, каждая из которых замещается значением любого окружения
оболочки shell с тем же самым именем. Если одна из этих переменных указана
(например, в /etc/yum.conf) и переменная окружения оболочки с тем же именем не
существует, тогда переменная файла конфигурации не будет замещена.</p>

<h3>1.3.4 Создание репозитория Yum</h3>

<p>Для создания репозитория, следуйте следующим указаниям:</p>

<ol>
<li><p>Установить пакет createrepo:</p>

<pre><code> # yum install createrepo
</code></pre></li>
<li><p>Скопировать все пакеты в один каталог, например, /mnt/local_repo</p></li>
<li><p>Запустить команду createrepo &#8211;database, указав этот каталог:</p>

<pre><code> # createrepo --database /mnt/local_repo
</code></pre></li>
</ol>


<p>===========================================================</p>

<p><strong> Важно </strong></p>

<p>Поскольку пакеты RPM для Red Hat Enterprise Linux 6 сжимаются с использованием
формата сжатия данных без потерь XZ и могут быть подписаны также
альтернативными (и более сильными) алгоритмами (например, SHA-256), запуск
createrepo от RHEL 5 не сможет создать пакет метаданных для RHEL 6.</p>

<p>===========================================================</p>

<p>Это создаст необходимые метаданные для нового репозитория, так же, как и базу
данных sqlite для ускорения операций yum.</p>

<h2>1.4 Дополнения Yum</h2>

<p>Yum предоставляет дополнения, которые расширяют и улучшают его операции.
Определенные дополнения устанавливаются по умолчанию. Yum всегда информирует о
том, какие дополнения загружены и активны каждый раз, как запускается команда
yum:</p>

<pre><code>    # yum info yum
    Loaded plugins: presto, refresh-packagekit, security
    [output truncated]
</code></pre>

<p>Заметьте, что имена дополнений, котоые следуют за Loaded plugins - это имена,
которые могут быть указаны в опции <code>--disableplugins=&lt;имя_дополнения&gt;</code>.</p>

<h3>1.4.1 Включение, настройка и отключение дополнений</h3>

<p>Для включения дополнений необходимо убедиться, что строка, начинающаяся с
plugins= представлена в секции [main] в /etc/yum.conf, и что ее значение
установлено в 1:</p>

<pre><code>    plugins=1
</code></pre>

<p>Можно отключить все дополнения, изменив 1 на 0.</p>

<p>===========================================================</p>

<p><strong> Информация </strong></p>

<p>Отключение дополнений не благоразумно</p>

<p>Отключение всех дополнений не благоразумно, поскольку определенные дополнения
обеспечивают важные сервисы Yum. В частности, rhnplugin позволяет подключение
к Red Hat Network, а security - позволяет системному администратору легко
обновлять систему с помощью обвнолений безопасности. Отключение дополнений
глобально - полезная опция, и, в основном, используется для диагностики
потенциальных проблем с Yum.</p>

<p>===========================================================</p>

<p>Каждое установленное дополнение имеет свой собственный файл конфигурации в
каталоге /etc/yum/pluginconf.d/. В этих файлах можно указать специфичные для
конкретного дополнения опции. Например, конфигурационный файл security.conf
для дополнения security:</p>

<pre><code>    [main]
    enabled=1
</code></pre>

<p>Файл конфигурации дополнения всегда содержит секцию [main], в которой есть
(или ее туда можно пометить при отсутствии) опция <code>enabled=</code>, которая
контролирует будет ли включено дополнение при запуске команды yum.</p>

<p>Если выключить все дополнения, установив <code>enabled=0</code> в /etc/yum.conf, все
дополнения будут отключены, не взирая на то, что они могут быть включены в
своих файлах конфигурации.</p>

<p>Если требуется единоразово отключить все дополнения для единственной команды
yum, используйте опцию <code>--noplugins</code>.</p>

<p>Если же просто требуется отключить один или несколько дополнений, протсо
добавьте опцию <code>--disableplugin=&lt;имя_дополнения&gt;</code>:</p>

<pre><code>    # yum update --disableplugin=presto
</code></pre>

<p>Имена дополнений, указанные в опции <code>--disableplugin=</code> - те же самые, что
перечисляются после строки Loaded plugins: в выводе любой команды yum. Можно
отключить несколько дополнений, разделив их имена с помощью запятой. Кроме
того, можно сопоставить множество похожих имен дополнений или просто укоротить
длинные имена, используя глобальные выражения: <code>--disableplugin=presto,refresh-pack*</code>.</p>

<h3>1.4.2 Установка дополнений</h3>

<p>Дополнения обычно именуются согласно соглашению об именовании пакетов путем
&#8220;склеивания&#8221; yum-plugin-&lt;имя_дополнения>, но не всегда: пакет, который
предоставляет дополнение presto называется yum-presto, например. Дополнение
можно установить тем же путем, что и другие пакеты:</p>

<pre><code>    # yum install yum-plugin-security
</code></pre>

<h3>1.4.3 Описания дополнений</h3>

<p>Здесь представлено описание нескольких полезных дополнений:</p>

<p><strong>presto (yum-presto)</strong></p>

<p>Дополнение presto добавляет поддержку для скачивания пакетов delta RPM, в
процессе обновления, из репозиториев, у которых включена поддержка метаданных
presto. Delta RPMs содержат только изменения между версиями пакета,
установленного у клиента, запрашивающего пакет, и обновленной версии в
репозитории. Процесс получения delta RPM более быстрый, чем скачивание целиком
обновленного пакета, и может значительно ускорить процесс обновления. Как
только delta RPM скачан, он должен быть пересобран (с учетом различий,
примененных к утсановленному в данное время пакету для создания полностью
обновленного пакета) на устанавливающей машине, что требует времени ЦП.
Использование delta RPM, однако, это компромис между временем на получение
пакета, которое зависит от сетевого соединения, и временем на пересборку,
которое зависит от возможностей ЦП. Использование дополнения presto
рекомендуется на быстрых машинах и системах с медленным сетевым подключением,
тогда как медленные машины с быстрым подключением могут получить преимущества
в процессе получения пакета, выключив presto. Дополнение presto включено по
умолчанию.</p>

<p><strong>protect-packages (yum-plugin-protect-packages)</strong></p>

<p>Дополнение protect-packages защищает пакет yum и все пакеты, от которых он
зависит, от преднамерянного или случайного удаления. Эта простая схема
защищает многие важные пакеты, необходимые для работы системы, от удаления.
Кроме того, можно перечислить дополнительные пакеты, один на строку, в файле
/etc/sysconfig/protected-packages (который необходимо создать при его
отсутствие), и protect-packages распространит свою защиту от удаления и на эти
пакеты также. Для временной перезаписи защиты пакетов используйте опцию
&#8211;override-protection при применении команды yum.</p>

<p><strong>rhnplugin (yum-rhn-plugin)</strong></p>

<p>rhnplugin обеспечивает поддержку для подключения к Red Hat Network (RHN).
Системы, зарегистрированные с помощью RHN, могут обновлять и устанавливать
пакеты из Red Hat Network.</p>

<p>За подробной информацией обращайтесь к man rhnplugin.</p>

<p><strong>refresh-packagekit (PackageKit-yum-plugin)</strong></p>

<p>Это дополнение обновляет метаданные для PackageKit во время работы yum.
Дополнение refresh-packagekit установлено по умолчанию.</p>

<p><strong>security (yum-plugin-security)</strong></p>

<p>Получение информации о наличии обвнолений безопасности и применение этих
обновлений как можно проще - очень важно для всех системных администраторов.
По этим причинам Yum предоставляет дополнение security, которое расширяет yum
с помощью набора команд, подкомманд и опций, крайне полезных с точки зрения
безопасности.</p>

<p>Наличие обновлений, относящихся к безопасности, можно проверить следующим
путем:</p>

<pre><code>    # yum check-update --security
    Loaded plugins: presto, refresh-packagekit, security
    Limiting package lists to security relevant ones
    Needed 3 of 7 packages, for security
    elinks.x86_64                   0.12-0.13.el6               rhel
    kernel.x86_64                   2.6.30.8-64.el6             rhel
    kernel-headers.x86_64           2.6.30.8-64.el6             rhel
</code></pre>

<p>Затем можно использовать или <code>yum update --security</code>, или <code>yum update-minimal --security</code> для обновления тех пакетов, которые подпадают под предупреждения о
проблемах безопасности. Обе эти команды обновляют все пакеты в системе, для
которых были получены предупреждения. <code>yum update-minimal --security</code> обновляет
их до последних версий пакетов, которые были выпущены как часть предупреждений
безопасности, тогда как <code>yum update --security</code> обновит все пакеты с выданными
предупреждениями до последней существующей версии этих пакетов.</p>

<p>Другими словами, если:</p>

<ul>
<li>пакет kernel-2.6.30.8-16 установлен в системе;</li>
<li>пакет kernel-2.6.30.8-32 был выпущен в качестве обновления безопасности;</li>
<li>пакет kernel-2.6.30.8-64 был выпущен как пакет исправлений,</li>
</ul>


<p>то <code>yum update-minimal --security</code> обновит систему до kernel-2.6.30.8-32, а <code>yum update --security</code> - до kernel-2.6.30.8-64. Консервативные системные
администраторы могут захотеть использовать <code>update-minimal</code> для уменьшения
риска, принесенного обновлением пакетов до максимально возможных.</p>

<p>Обращайтесь к man yum-security для подробностями и дальнейшего изучения
возможностей дополнения security.</p>

<h2>Дополнительные ресурсы:</h2>

<ul>
<li>The Yum home page and wiki —
<a href="http://yum.baseurl.org/wiki/Guides">http://yum.baseurl.org/wiki/Guides</a></li>
<li>Managing Software with Yum — <a href="http://docs.fedoraproject.org/en-US/Fedora_Core/5/html-single/Software_Management_Guide/">http://docs.fedoraproject.org/en-US/Fedora_Core/5/html-single/Software_Management_Guide/</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
